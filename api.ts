/* tslint:disable */
/* eslint-disable */
/**
 * Pickup API
 * # Authorization   Pickup API accepts one type of authentication   <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CartDTO
 */
export interface CartDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof CartDTO
     */
    'items': Array<CartItemDTO>;
    /**
     * 
     * @type {CartDTODeliveryOption}
     * @memberof CartDTO
     */
    'delivery_option'?: CartDTODeliveryOption;
    /**
     * 
     * @type {CustomerDetailDTO}
     * @memberof CartDTO
     */
    'customer'?: CustomerDetailDTO;
    /**
     * PickupPH supported order types
     * @type {string}
     * @memberof CartDTO
     */
    'order_type': CartDTOOrderTypeEnum;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof CartDTO
     */
    'order_date'?: string;
    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof CartDTO
     */
    'order_time'?: string;
}

export const CartDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type CartDTOOrderTypeEnum = typeof CartDTOOrderTypeEnum[keyof typeof CartDTOOrderTypeEnum];

/**
 * Optional variable for delivery option
 * @export
 * @interface CartDTODeliveryOption
 */
export interface CartDTODeliveryOption {
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof CartDTODeliveryOption
     */
    'delivery_payment_method'?: CartDTODeliveryOptionDeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request
     * @type {string}
     * @memberof CartDTODeliveryOption
     */
    'delivery_vehicle': CartDTODeliveryOptionDeliveryVehicleEnum;
}

export const CartDTODeliveryOptionDeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type CartDTODeliveryOptionDeliveryPaymentMethodEnum = typeof CartDTODeliveryOptionDeliveryPaymentMethodEnum[keyof typeof CartDTODeliveryOptionDeliveryPaymentMethodEnum];
export const CartDTODeliveryOptionDeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type CartDTODeliveryOptionDeliveryVehicleEnum = typeof CartDTODeliveryOptionDeliveryVehicleEnum[keyof typeof CartDTODeliveryOptionDeliveryVehicleEnum];

/**
 * 
 * @export
 * @interface CartEntity
 */
export interface CartEntity {
    /**
     * 
     * @type {string}
     * @memberof CartEntity
     */
    'checkout_url': string;
    /**
     * Updates will be sent for this cart via webhook using this identifier
     * @type {string}
     * @memberof CartEntity
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CartItemDTO
 */
export interface CartItemDTO {
    /**
     * The 24 character hexadecimal string id of the item to be added or modified
     * @type {string}
     * @memberof CartItemDTO
     */
    'id': string;
    /**
     * The item quantity to be set, 0 means item is for removal
     * @type {number}
     * @memberof CartItemDTO
     */
    'quantity': number;
    /**
     * The extra option per item
     * @type {Array<string>}
     * @memberof CartItemDTO
     */
    'extras'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CategoryClass
 */
export interface CategoryClass {
    /**
     * Indicates an item to be an exclusive offering in a meal plan type order
     * @type {boolean}
     * @memberof CategoryClass
     */
    'is_exclusive': boolean;
    /**
     * Category identifier
     * @type {string}
     * @memberof CategoryClass
     */
    'category_name': string;
    /**
     * Position of the category in the menu
     * @type {number}
     * @memberof CategoryClass
     */
    'category_position': number;
    /**
     * The limit of category per day , 0 = category is not limited
     * @type {number}
     * @memberof CategoryClass
     */
    'category_limit_per_day': number;
    /**
     * Limit of category per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof CategoryClass
     */
    'category_limit_per_time_slot': Array<ItemTimeSlotClass>;
    /**
     * True if the category should be visible to the customer
     * @type {boolean}
     * @memberof CategoryClass
     */
    'visible': boolean;
}
/**
 * 
 * @export
 * @interface CustomerAddressDTO
 */
export interface CustomerAddressDTO {
    /**
     * 
     * @type {number}
     * @memberof CustomerAddressDTO
     */
    'lng': number;
    /**
     * 
     * @type {number}
     * @memberof CustomerAddressDTO
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface CustomerDetailDTO
 */
export interface CustomerDetailDTO {
    /**
     * 
     * @type {CustomerAddressDTO}
     * @memberof CustomerDetailDTO
     */
    'address'?: CustomerAddressDTO;
    /**
     * 
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'last_name'?: string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'mobile_number'?: string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'email'?: string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CustomerQuoteDTO
 */
export interface CustomerQuoteDTO {
    /**
     * 
     * @type {CustomerAddressDTO}
     * @memberof CustomerQuoteDTO
     */
    'address': CustomerAddressDTO;
    /**
     * 
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'mobile_number': string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'email': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeliveryOptionDTO
 */
export interface DeliveryOptionDTO {
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof DeliveryOptionDTO
     */
    'delivery_payment_method'?: DeliveryOptionDTODeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request
     * @type {string}
     * @memberof DeliveryOptionDTO
     */
    'delivery_vehicle': DeliveryOptionDTODeliveryVehicleEnum;
}

export const DeliveryOptionDTODeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type DeliveryOptionDTODeliveryPaymentMethodEnum = typeof DeliveryOptionDTODeliveryPaymentMethodEnum[keyof typeof DeliveryOptionDTODeliveryPaymentMethodEnum];
export const DeliveryOptionDTODeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type DeliveryOptionDTODeliveryVehicleEnum = typeof DeliveryOptionDTODeliveryVehicleEnum[keyof typeof DeliveryOptionDTODeliveryVehicleEnum];

/**
 * 
 * @export
 * @interface DeliveryQuotationEntity
 */
export interface DeliveryQuotationEntity {
    /**
     * Quoted Delivery Fee from respective partner
     * @type {number}
     * @memberof DeliveryQuotationEntity
     */
    'delivery_fee': number;
    /**
     * Delivery Partner quotation source
     * @type {string}
     * @memberof DeliveryQuotationEntity
     */
    'partner': string;
    /**
     * Indicator for the success quotation
     * @type {boolean}
     * @memberof DeliveryQuotationEntity
     */
    'is_success': boolean;
    /**
     * Indicator for the success quotation
     * @type {Array<string>}
     * @memberof DeliveryQuotationEntity
     */
    'message'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeliveryQuotationResultEntity
 */
export interface DeliveryQuotationResultEntity {
    /**
     * 
     * @type {DeliveryQuotationEntity}
     * @memberof DeliveryQuotationResultEntity
     */
    'selected': DeliveryQuotationEntity;
    /**
     * List of active delivery partners from quotation , for quotation reference on multihailing stores
     * @type {Array<DeliveryQuotationEntity>}
     * @memberof DeliveryQuotationResultEntity
     */
    'delivery_partner_quotations'?: Array<DeliveryQuotationEntity>;
}
/**
 * 
 * @export
 * @interface ExtraGroupClass
 */
export interface ExtraGroupClass {
    /**
     * Indicates if extras within a group is REQUIRED to be added on cart with the item
     * @type {boolean}
     * @memberof ExtraGroupClass
     */
    'is_required': boolean;
    /**
     * The name of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'name': string;
    /**
     * The description of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'description': string;
    /**
     * Minimum number of extras within a group that NEEDS to be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'minimum_number': number;
    /**
     * Maximum number of extras within a group that can be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'maximum_number': number;
    /**
     * List of extras within a group
     * @type {Array<GroupSelectionClass>}
     * @memberof ExtraGroupClass
     */
    'extras'?: Array<GroupSelectionClass>;
}
/**
 * 
 * @export
 * @interface GroupSelectionClass
 */
export interface GroupSelectionClass {
    /**
     * The unique bson identifier of the extra, to be used on the create cart endpoint
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'id'?: string;
    /**
     * Nominated position of the extra in a list
     * @type {number}
     * @memberof GroupSelectionClass
     */
    'position': number;
    /**
     * Random unique identifier for extras
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'extra_code': string;
    /**
     * Pertains to the regular price of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'price': string;
    /**
     * The name of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ItemClass
 */
export interface ItemClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemClass
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof ItemClass
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof ItemClass
     */
    'item_code': string;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_meal_plan'?: boolean;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof ItemClass
     */
    'item_limit_per_day'?: number;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof ItemClass
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'tags': Array<string>;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemClass
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemInventoryEntity
 */
export interface ItemInventoryEntity {
    /**
     * Number of available item quantity
     * @type {number}
     * @memberof ItemInventoryEntity
     */
    'available': number;
}
/**
 * 
 * @export
 * @interface ItemPartialClass
 */
export interface ItemPartialClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemPartialClass
     */
    'id'?: string;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemPartialClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemPartialClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemPartialClass
     */
    'tags': Array<string>;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemPartialClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemTimeSlotClass
 */
export interface ItemTimeSlotClass {
    /**
     * Time-slot indicator
     * @type {string}
     * @memberof ItemTimeSlotClass
     */
    'time_slot': string;
    /**
     * Indicates the limit of purchases an item could have in a time slot
     * @type {number}
     * @memberof ItemTimeSlotClass
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ItemsEntity
 */
export interface ItemsEntity {
    /**
     * 
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemsEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<ItemPartialClass>}
     * @memberof ItemsEntity
     */
    'result': Array<ItemPartialClass>;
    /**
     * 
     * @type {number}
     * @memberof ItemsEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface MenuClass
 */
export interface MenuClass {
    /**
     * 
     * @type {MenuClassItem}
     * @memberof MenuClass
     */
    'item': MenuClassItem;
    /**
     * Item limit per day 0 = category is not limited
     * @type {number}
     * @memberof MenuClass
     */
    'item_limit_per_day': number;
    /**
     * To check if the item is available
     * @type {boolean}
     * @memberof MenuClass
     */
    'available': boolean;
    /**
     * True if the item should be visible to the customer , item can be available but not be visible
     * @type {boolean}
     * @memberof MenuClass
     */
    'visible': boolean;
    /**
     * Position of the item in the store menu
     * @type {number}
     * @memberof MenuClass
     */
    'order_position': number;
    /**
     * Item category name
     * @type {string}
     * @memberof MenuClass
     */
    'category': string;
    /**
     * Item limit per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClass
     */
    'item_limit_per_time_slot': Array<ItemTimeSlotClass>;
}
/**
 * Item id that will be used for cart building on /cart route
 * @export
 * @interface MenuClassItem
 */
export interface MenuClassItem {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof MenuClassItem
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof MenuClassItem
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof MenuClassItem
     */
    'item_code': string;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_meal_plan'?: boolean;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof MenuClassItem
     */
    'item_limit_per_day'?: number;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClassItem
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof MenuClassItem
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof MenuClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof MenuClassItem
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof MenuClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof MenuClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof MenuClassItem
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'tags': Array<string>;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof MenuClassItem
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderDetailsClass
 */
export interface OrderDetailsClass {
    /**
     * Item order quantity
     * @type {number}
     * @memberof OrderDetailsClass
     */
    'quantity': number;
    /**
     * 
     * @type {OrderDetailsClassItem}
     * @memberof OrderDetailsClass
     */
    'item'?: OrderDetailsClassItem;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderDetailsClass
     */
    'id': string;
    /**
     * 
     * @type {Array<OrderExtraClass>}
     * @memberof OrderDetailsClass
     */
    'extras': Array<OrderExtraClass>;
}
/**
 * Item information
 * @export
 * @interface OrderDetailsClassItem
 */
export interface OrderDetailsClassItem {
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'regular_price': string;
}
/**
 * 
 * @export
 * @interface OrderEntity
 */
export interface OrderEntity {
    /**
     * 
     * @type {boolean}
     * @memberof OrderEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<OrderPartialClass>}
     * @memberof OrderEntity
     */
    'result': Array<OrderPartialClass>;
    /**
     * 
     * @type {number}
     * @memberof OrderEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface OrderExtraClass
 */
export interface OrderExtraClass {
    /**
     * Unique extra code
     * @type {string}
     * @memberof OrderExtraClass
     */
    'code': string;
    /**
     * Name of the extra
     * @type {string}
     * @memberof OrderExtraClass
     */
    'name': string;
    /**
     * Pertains to the regular price of the extra
     * @type {string}
     * @memberof OrderExtraClass
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface OrderItemClass
 */
export interface OrderItemClass {
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof OrderItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof OrderItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof OrderItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof OrderItemClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof OrderItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof OrderItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof OrderItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof OrderItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof OrderItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof OrderItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof OrderItemClass
     */
    'regular_price': string;
}
/**
 * 
 * @export
 * @interface OrderPartialClass
 */
export interface OrderPartialClass {
    /**
     * Order ID that will be used to search
     * @type {string}
     * @memberof OrderPartialClass
     */
    'id': string;
    /**
     * 
     * @type {OrderPartialClassStoreDetails}
     * @memberof OrderPartialClass
     */
    'store_details': OrderPartialClassStoreDetails;
    /**
     * Guest customer information
     * @type {object}
     * @memberof OrderPartialClass
     */
    'customer': object;
    /**
     * Total order amount
     * @type {number}
     * @memberof OrderPartialClass
     */
    'total_amount'?: number;
    /**
     * Delivery fee charged if order type is delivery
     * @type {string}
     * @memberof OrderPartialClass
     */
    'charged_delivery_fee': string;
    /**
     * Indicates delivery fee was paid via cash
     * @type {boolean}
     * @memberof OrderPartialClass
     */
    'delivery_paid_by_cash': boolean;
    /**
     * Order type
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_type': OrderPartialClassOrderTypeEnum;
    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_date': string;
    /**
     * Order time filter in HH:MM format
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_time': string;
    /**
     * Order delivery address, empty if order type is pickup or curbside pickup
     * @type {string}
     * @memberof OrderPartialClass
     */
    'delivery_address': string;
    /**
     * Order status, expired means the cart was abandoned
     * @type {string}
     * @memberof OrderPartialClass
     */
    'status'?: OrderPartialClassStatusEnum;
    /**
     * Order Details
     * @type {Array<OrderDetailsClass>}
     * @memberof OrderPartialClass
     */
    'order_details': Array<OrderDetailsClass>;
    /**
     * Status update timestamps
     * @type {object}
     * @memberof OrderPartialClass
     */
    'change_timestamp': object;
    /**
     * Transaction number, this serves as pickup\'s order number
     * @type {string}
     * @memberof OrderPartialClass
     */
    'transaction_number': string;
    /**
     * Payment method used
     * @type {string}
     * @memberof OrderPartialClass
     */
    'payment_method'?: string;
    /**
     * Refunded amount, can be partial or full
     * @type {number}
     * @memberof OrderPartialClass
     */
    'refunded_amount': number;
    /**
     * Third party pickup information
     * @type {object}
     * @memberof OrderPartialClass
     */
    'pickup_details': object;
    /**
     * Tracking page for this particular order
     * @type {string}
     * @memberof OrderPartialClass
     */
    'tracking_page': string;
}

export const OrderPartialClassOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type OrderPartialClassOrderTypeEnum = typeof OrderPartialClassOrderTypeEnum[keyof typeof OrderPartialClassOrderTypeEnum];
export const OrderPartialClassStatusEnum = {
    New: 'new',
    Cancelled: 'cancelled',
    Completed: 'completed',
    Refunded: 'refunded',
    Expired: 'expired',
    PaymentFailed: 'payment_failed'
} as const;

export type OrderPartialClassStatusEnum = typeof OrderPartialClassStatusEnum[keyof typeof OrderPartialClassStatusEnum];

/**
 * Store Details
 * @export
 * @interface OrderPartialClassStoreDetails
 */
export interface OrderPartialClassStoreDetails {
    /**
     * Store ID where order was made
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface PromoDTO
 */
export interface PromoDTO {
    /**
     * Promo code
     * @type {string}
     * @memberof PromoDTO
     */
    'promo_code': string;
    /**
     * Store ID where the promo needs to be validated against
     * @type {string}
     * @memberof PromoDTO
     */
    'store_id': string;
    /**
     * Total price of the items in cart
     * @type {number}
     * @memberof PromoDTO
     */
    'total_amount': number;
    /**
     * Intended order type for this promo
     * @type {string}
     * @memberof PromoDTO
     */
    'order_type': PromoDTOOrderTypeEnum;
}

export const PromoDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type PromoDTOOrderTypeEnum = typeof PromoDTOOrderTypeEnum[keyof typeof PromoDTOOrderTypeEnum];

/**
 * 
 * @export
 * @interface PromoDiscountDetails
 */
export interface PromoDiscountDetails {
    /**
     * Total amount to be paid, used as base of calculation
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'original': number;
    /**
     * Total amount after promo is applied
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'applied': number;
    /**
     * Total promo value
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface PromoEntity
 */
export interface PromoEntity {
    /**
     * Promo code
     * @type {string}
     * @memberof PromoEntity
     */
    'code': string;
    /**
     * Type of this promo
     * @type {string}
     * @memberof PromoEntity
     */
    'type': PromoEntityTypeEnum;
    /**
     * Identifies order types this promo belongs to
     * @type {Array<string>}
     * @memberof PromoEntity
     */
    'applies_to': Array<string>;
    /**
     * Promo discount as amount deductable
     * @type {number}
     * @memberof PromoEntity
     */
    'amount_off': number;
    /**
     * Promo discount as percentage
     * @type {number}
     * @memberof PromoEntity
     */
    'percentage_off': number;
    /**
     * Promo discount for delivery fee
     * @type {number}
     * @memberof PromoEntity
     */
    'subsidized_delivery_amount': number;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof PromoEntity
     */
    'minimum_purchase': number;
    /**
     * Promo description
     * @type {string}
     * @memberof PromoEntity
     */
    'free_item_description'?: string;
    /**
     * Promo start date
     * @type {string}
     * @memberof PromoEntity
     */
    'start_date': string;
    /**
     * Promo end date
     * @type {string}
     * @memberof PromoEntity
     */
    'end_date': string;
}

export const PromoEntityTypeEnum = {
    FreeItem: 'free_item',
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery'
} as const;

export type PromoEntityTypeEnum = typeof PromoEntityTypeEnum[keyof typeof PromoEntityTypeEnum];

/**
 * 
 * @export
 * @interface PromoListResponse
 */
export interface PromoListResponse {
    /**
     * List of promos
     * @type {Array<PromoEntity>}
     * @memberof PromoListResponse
     */
    'promos': Array<PromoEntity>;
}
/**
 * 
 * @export
 * @interface QuotationRequestDTO
 */
export interface QuotationRequestDTO {
    /**
     * 
     * @type {QuotationRequestDTOCustomer}
     * @memberof QuotationRequestDTO
     */
    'customer': QuotationRequestDTOCustomer;
    /**
     * The 24 character hexadecimal string id of the store to be search for delivery availability and details
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'id': string;
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'delivery_payment_method': QuotationRequestDTODeliveryPaymentMethodEnum;
    /**
     * Customer Delivery Address String
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'address_string': string;
    /**
     * Delivery Vehicle Type for the request , null will default to motorcycle
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'delivery_vehicle': QuotationRequestDTODeliveryVehicleEnum;
    /**
     * Delivery schedule time in HH:MM format , null will default to asap
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'order_time'?: string;
    /**
     * Delivery Date, null will default to asap ISO8601 compliant date string, defaults to current server date ,
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'order_date'?: string;
}

export const QuotationRequestDTODeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type QuotationRequestDTODeliveryPaymentMethodEnum = typeof QuotationRequestDTODeliveryPaymentMethodEnum[keyof typeof QuotationRequestDTODeliveryPaymentMethodEnum];
export const QuotationRequestDTODeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type QuotationRequestDTODeliveryVehicleEnum = typeof QuotationRequestDTODeliveryVehicleEnum[keyof typeof QuotationRequestDTODeliveryVehicleEnum];

/**
 * Customer Details
 * @export
 * @interface QuotationRequestDTOCustomer
 */
export interface QuotationRequestDTOCustomer {
    /**
     * 
     * @type {CustomerAddressDTO}
     * @memberof QuotationRequestDTOCustomer
     */
    'address': CustomerAddressDTO;
    /**
     * 
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'mobile_number': string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'email': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface StoreClass
 */
export interface StoreClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreClass
     */
    'delivery_distance_limit': number;
    /**
     * Store accepts curbside delivery
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_curbside_active': boolean;
    /**
     * Store accepts pickup order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_pickup_active': boolean;
    /**
     * Store accepts delivery order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_delivery_active': boolean;
    /**
     * Store accepts mealplan order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_meal_plan_active': boolean;
    /**
     * Store accepts dine in order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_dine_in_active': boolean;
    /**
     * Total allowed number of items purchased on a store per day
     * @type {number}
     * @memberof StoreClass
     */
    'store_item_limit_per_day': number;
    /**
     * Indicates if a store accepts and process orders any time of the day
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_open_24_hours': boolean;
    /**
     * List of dates that indicates the store as closed and will NOT accept orders
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'off_dates': Array<string>;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StoreClass
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StoreClass
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store menu grouped and ordered by category
     * @type {Array<MenuClass>}
     * @memberof StoreClass
     */
    'menu': Array<MenuClass>;
    /**
     * Available delivery payment method
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'delivery_payment_methods': Array<string>;
    /**
     * Store category list
     * @type {Array<CategoryClass>}
     * @memberof StoreClass
     */
    'categories': Array<CategoryClass>;
    /**
     * Helper for expected meal plan deliveries dates
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'meal_plan_dates': Array<string>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'store_tags'?: Array<string>;
    /**
     * List of items related to name
     * @type {Array<ItemPartialClass>}
     * @memberof StoreClass
     */
    'searched_items'?: Array<ItemPartialClass>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_accepting_in_advanced_orders': boolean;
}
/**
 * 
 * @export
 * @interface StoreDetailsClass
 */
export interface StoreDetailsClass {
    /**
     * Store ID where order was made
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface StoreHoursClass
 */
export interface StoreHoursClass {
    /**
     * Indicates if the store is open on the specific day
     * @type {boolean}
     * @memberof StoreHoursClass
     */
    'is_open': boolean;
    /**
     * Day of the week 0 = Sunday, 1 = Monday , 2 = Tuesday...
     * @type {string}
     * @memberof StoreHoursClass
     */
    'day': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'opening': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'closing': string;
}
/**
 * 
 * @export
 * @interface StorePartialClass
 */
export interface StorePartialClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StorePartialClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StorePartialClass
     */
    'delivery_distance_limit': number;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StorePartialClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StorePartialClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StorePartialClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StorePartialClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StorePartialClass
     */
    'store_tags'?: Array<string>;
    /**
     * List of items related to name
     * @type {Array<ItemPartialClass>}
     * @memberof StorePartialClass
     */
    'searched_items'?: Array<ItemPartialClass>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StorePartialClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_accepting_in_advanced_orders': boolean;
}
/**
 * 
 * @export
 * @interface StoresEntity
 */
export interface StoresEntity {
    /**
     * 
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof StoresEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<StorePartialClass>}
     * @memberof StoresEntity
     */
    'result': Array<StorePartialClass>;
    /**
     * 
     * @type {number}
     * @memberof StoresEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface ValidPromoEntity
 */
export interface ValidPromoEntity {
    /**
     * Type of this promo
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'type': ValidPromoEntityTypeEnum;
    /**
     * 
     * @type {ValidPromoEntityPromo}
     * @memberof ValidPromoEntity
     */
    'promo'?: ValidPromoEntityPromo;
    /**
     * Calculated discount for delivery fee
     * @type {number}
     * @memberof ValidPromoEntity
     */
    'delivery_discount': number;
    /**
     * Promo description
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'description'?: string;
    /**
     * Promo expiry
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'end_date'?: string;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof ValidPromoEntity
     */
    'minimum_purchase'?: number;
}

export const ValidPromoEntityTypeEnum = {
    FreeItem: 'free_item',
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery'
} as const;

export type ValidPromoEntityTypeEnum = typeof ValidPromoEntityTypeEnum[keyof typeof ValidPromoEntityTypeEnum];

/**
 * Calculated discount base on total amount
 * @export
 * @interface ValidPromoEntityPromo
 */
export interface ValidPromoEntityPromo {
    /**
     * Total amount to be paid, used as base of calculation
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'original': number;
    /**
     * Total amount after promo is applied
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'applied': number;
    /**
     * Total promo value
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'total': number;
}

/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate: async (cartDTO: CartDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDTO' is not null or undefined
            assertParamExists('cartControllerCreate', 'cartDTO', cartDTO)
            const localVarPath = `/v1/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerCreate(cartDTO: CartDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerCreate(cartDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate(cartDTO: CartDTO, options?: any): AxiosPromise<CartEntity> {
            return localVarFp.cartControllerCreate(cartDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cartControllerCreate operation in CartApi.
 * @export
 * @interface CartApiCartControllerCreateRequest
 */
export interface CartApiCartControllerCreateRequest {
    /**
     * 
     * @type {CartDTO}
     * @memberof CartApiCartControllerCreate
     */
    readonly cartDTO: CartDTO
}

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Create cart
     * @param {CartApiCartControllerCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerCreate(requestParameters: CartApiCartControllerCreateRequest, options?: AxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerCreate(requestParameters.cartDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo(options?: any): AxiosPromise<object> {
            return localVarFp.appControllerGetServerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get server information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetServerInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeliveryApi - axios parameter creator
 * @export
 */
export const DeliveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryControllerGetQuotation: async (quotationRequestDTO: QuotationRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quotationRequestDTO' is not null or undefined
            assertParamExists('deliveryControllerGetQuotation', 'quotationRequestDTO', quotationRequestDTO)
            const localVarPath = `/v1/delivery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quotationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeliveryApi - functional programming interface
 * @export
 */
export const DeliveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeliveryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryControllerGetQuotation(quotationRequestDTO: QuotationRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryQuotationResultEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryControllerGetQuotation(quotationRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeliveryApi - factory interface
 * @export
 */
export const DeliveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeliveryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryControllerGetQuotation(quotationRequestDTO: QuotationRequestDTO, options?: any): AxiosPromise<DeliveryQuotationResultEntity> {
            return localVarFp.deliveryControllerGetQuotation(quotationRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deliveryControllerGetQuotation operation in DeliveryApi.
 * @export
 * @interface DeliveryApiDeliveryControllerGetQuotationRequest
 */
export interface DeliveryApiDeliveryControllerGetQuotationRequest {
    /**
     * 
     * @type {QuotationRequestDTO}
     * @memberof DeliveryApiDeliveryControllerGetQuotation
     */
    readonly quotationRequestDTO: QuotationRequestDTO
}

/**
 * DeliveryApi - object-oriented interface
 * @export
 * @class DeliveryApi
 * @extends {BaseAPI}
 */
export class DeliveryApi extends BaseAPI {
    /**
     * 
     * @summary Get Quotation
     * @param {DeliveryApiDeliveryControllerGetQuotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeliveryApi
     */
    public deliveryControllerGetQuotation(requestParameters: DeliveryApiDeliveryControllerGetQuotationRequest, options?: AxiosRequestConfig) {
        return DeliveryApiFp(this.configuration).deliveryControllerGetQuotation(requestParameters.quotationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId: async (id: string, storeId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerAggregateId', 'id', id)
            const localVarPath = `/v1/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch: async (name?: string, storeId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity: async (id: string, orderDate?: string, orderTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerGetSoldQuantity', 'id', id)
            const localVarPath = `/v1/item/{id}/stock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateId(id: string, storeId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateId(id, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateSearch(name, storeId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemInventoryEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerGetSoldQuantity(id, orderDate, orderTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId(id: string, storeId?: string, options?: any): AxiosPromise<ItemClass> {
            return localVarFp.itemControllerAggregateId(id, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ItemsEntity> {
            return localVarFp.itemControllerAggregateSearch(name, storeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: any): AxiosPromise<ItemInventoryEntity> {
            return localVarFp.itemControllerGetSoldQuantity(id, orderDate, orderTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for itemControllerAggregateId operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateIdRequest
 */
export interface ItemApiItemControllerAggregateIdRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly id: string

    /**
     * ID of store
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly storeId?: string
}

/**
 * Request parameters for itemControllerAggregateSearch operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateSearchRequest
 */
export interface ItemApiItemControllerAggregateSearchRequest {
    /**
     * Item name search key, part of full name
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly name?: string

    /**
     * Filter items via store ID
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly storeId?: string

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly offset?: number
}

/**
 * Request parameters for itemControllerGetSoldQuantity operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerGetSoldQuantityRequest
 */
export interface ItemApiItemControllerGetSoldQuantityRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly id: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderDate?: string

    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderTime?: string
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Get item data
     * @param {ItemApiItemControllerAggregateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateId(requestParameters: ItemApiItemControllerAggregateIdRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateId(requestParameters.id, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search items by name
     * @param {ItemApiItemControllerAggregateSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateSearch(requestParameters: ItemApiItemControllerAggregateSearchRequest = {}, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateSearch(requestParameters.name, requestParameters.storeId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get inventory of an item
     * @param {ItemApiItemControllerGetSoldQuantityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerGetSoldQuantity(requestParameters: ItemApiItemControllerGetSoldQuantityRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerGetSoldQuantity(requestParameters.id, requestParameters.orderDate, requestParameters.orderTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Order type
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFind: async (id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersControllerFind', 'id', id)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (maxOrderDate !== undefined) {
                localVarQueryParameter['max_order_date'] = maxOrderDate;
            }

            if (minOrderDate !== undefined) {
                localVarQueryParameter['min_order_date'] = minOrderDate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Order type
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersControllerFind(id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersControllerFind(id, maxOrderDate, minOrderDate, status, orderType, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Order type
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFind(id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', limit?: number, offset?: number, options?: any): AxiosPromise<OrderEntity> {
            return localVarFp.ordersControllerFind(id, maxOrderDate, minOrderDate, status, orderType, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ordersControllerFind operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersControllerFindRequest
 */
export interface OrdersApiOrdersControllerFindRequest {
    /**
     * Customer ID that you passed to us
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly id: string

    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly maxOrderDate?: string

    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly minOrderDate?: string

    /**
     * Order status filter
     * @type {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'

    /**
     * Order type
     * @type {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly offset?: number
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Get customer order history
     * @param {OrdersApiOrdersControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersControllerFind(requestParameters: OrdersApiOrdersControllerFindRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersControllerFind(requestParameters.id, requestParameters.maxOrderDate, requestParameters.minOrderDate, requestParameters.status, requestParameters.orderType, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromoApi - axios parameter creator
 * @export
 */
export const PromoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerGetPromosByStore: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('promoControllerGetPromosByStore', 'storeId', storeId)
            const localVarPath = `/v1/promo/{store_id}`
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerValidatePromo: async (promoDTO: PromoDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoDTO' is not null or undefined
            assertParamExists('promoControllerValidatePromo', 'promoDTO', promoDTO)
            const localVarPath = `/v1/promo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromoApi - functional programming interface
 * @export
 */
export const PromoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerGetPromosByStore(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerGetPromosByStore(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerValidatePromo(promoDTO: PromoDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidPromoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerValidatePromo(promoDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromoApi - factory interface
 * @export
 */
export const PromoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerGetPromosByStore(storeId: string, options?: any): AxiosPromise<PromoListResponse> {
            return localVarFp.promoControllerGetPromosByStore(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerValidatePromo(promoDTO: PromoDTO, options?: any): AxiosPromise<ValidPromoEntity> {
            return localVarFp.promoControllerValidatePromo(promoDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for promoControllerGetPromosByStore operation in PromoApi.
 * @export
 * @interface PromoApiPromoControllerGetPromosByStoreRequest
 */
export interface PromoApiPromoControllerGetPromosByStoreRequest {
    /**
     * Store ID of the list of promos you want to fetch
     * @type {string}
     * @memberof PromoApiPromoControllerGetPromosByStore
     */
    readonly storeId: string
}

/**
 * Request parameters for promoControllerValidatePromo operation in PromoApi.
 * @export
 * @interface PromoApiPromoControllerValidatePromoRequest
 */
export interface PromoApiPromoControllerValidatePromoRequest {
    /**
     * 
     * @type {PromoDTO}
     * @memberof PromoApiPromoControllerValidatePromo
     */
    readonly promoDTO: PromoDTO
}

/**
 * PromoApi - object-oriented interface
 * @export
 * @class PromoApi
 * @extends {BaseAPI}
 */
export class PromoApi extends BaseAPI {
    /**
     * 
     * @summary Get list of promo per store
     * @param {PromoApiPromoControllerGetPromosByStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerGetPromosByStore(requestParameters: PromoApiPromoControllerGetPromosByStoreRequest, options?: AxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerGetPromosByStore(requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate promo and get calculated result
     * @param {PromoApiPromoControllerValidatePromoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerValidatePromo(requestParameters: PromoApiPromoControllerValidatePromoRequest, options?: AxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerValidatePromo(requestParameters.promoDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
         * @param {string} [name] General search key name for \&quot;store name\&quot;,\&quot;item name\&quot;, \&quot;item description\&quot;
         * @param {Array<string>} [tags] Store tags filter comma separated
         * @param {number} [maxDistance] Maximum store delivery distance in kilometers
         * @param {boolean} [openOnly] Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Store supported fulfillment service
         * @param {Array<string>} [ids] Filter store via id
         * @param {'popular_day'} [funnel] Custom data-driven filters
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind: async (orderDate?: string, orderTime?: string, name?: string, tags?: Array<string>, maxDistance?: number, openOnly?: boolean, orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', ids?: Array<string>, funnel?: 'popular_day', limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (maxDistance !== undefined) {
                localVarQueryParameter['max_distance'] = maxDistance;
            }

            if (openOnly !== undefined) {
                localVarQueryParameter['open_only'] = openOnly;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (funnel !== undefined) {
                localVarQueryParameter['funnel'] = funnel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerFindOne', 'id', id)
            const localVarPath = `/v1/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
         * @param {string} [name] General search key name for \&quot;store name\&quot;,\&quot;item name\&quot;, \&quot;item description\&quot;
         * @param {Array<string>} [tags] Store tags filter comma separated
         * @param {number} [maxDistance] Maximum store delivery distance in kilometers
         * @param {boolean} [openOnly] Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Store supported fulfillment service
         * @param {Array<string>} [ids] Filter store via id
         * @param {'popular_day'} [funnel] Custom data-driven filters
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFind(orderDate?: string, orderTime?: string, name?: string, tags?: Array<string>, maxDistance?: number, openOnly?: boolean, orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', ids?: Array<string>, funnel?: 'popular_day', limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFind(orderDate, orderTime, name, tags, maxDistance, openOnly, orderType, ids, funnel, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Find store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
         * @param {string} [name] General search key name for \&quot;store name\&quot;,\&quot;item name\&quot;, \&quot;item description\&quot;
         * @param {Array<string>} [tags] Store tags filter comma separated
         * @param {number} [maxDistance] Maximum store delivery distance in kilometers
         * @param {boolean} [openOnly] Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Store supported fulfillment service
         * @param {Array<string>} [ids] Filter store via id
         * @param {'popular_day'} [funnel] Custom data-driven filters
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind(orderDate?: string, orderTime?: string, name?: string, tags?: Array<string>, maxDistance?: number, openOnly?: boolean, orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', ids?: Array<string>, funnel?: 'popular_day', limit?: number, offset?: number, options?: any): AxiosPromise<StoresEntity> {
            return localVarFp.storeControllerFind(orderDate, orderTime, name, tags, maxDistance, openOnly, orderType, ids, funnel, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne(id: string, options?: any): AxiosPromise<StoreClass> {
            return localVarFp.storeControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeControllerFind operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindRequest
 */
export interface StoreApiStoreControllerFindRequest {
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof StoreApiStoreControllerFind
     */
    readonly orderDate?: string

    /**
     * Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
     * @type {string}
     * @memberof StoreApiStoreControllerFind
     */
    readonly orderTime?: string

    /**
     * General search key name for \&quot;store name\&quot;,\&quot;item name\&quot;, \&quot;item description\&quot;
     * @type {string}
     * @memberof StoreApiStoreControllerFind
     */
    readonly name?: string

    /**
     * Store tags filter comma separated
     * @type {Array<string>}
     * @memberof StoreApiStoreControllerFind
     */
    readonly tags?: Array<string>

    /**
     * Maximum store delivery distance in kilometers
     * @type {number}
     * @memberof StoreApiStoreControllerFind
     */
    readonly maxDistance?: number

    /**
     * Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
     * @type {boolean}
     * @memberof StoreApiStoreControllerFind
     */
    readonly openOnly?: boolean

    /**
     * Store supported fulfillment service
     * @type {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'}
     * @memberof StoreApiStoreControllerFind
     */
    readonly orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'

    /**
     * Filter store via id
     * @type {Array<string>}
     * @memberof StoreApiStoreControllerFind
     */
    readonly ids?: Array<string>

    /**
     * Custom data-driven filters
     * @type {'popular_day'}
     * @memberof StoreApiStoreControllerFind
     */
    readonly funnel?: 'popular_day'

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof StoreApiStoreControllerFind
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof StoreApiStoreControllerFind
     */
    readonly offset?: number
}

/**
 * Request parameters for storeControllerFindOne operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindOneRequest
 */
export interface StoreApiStoreControllerFindOneRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFindOne
     */
    readonly id: string
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Find store
     * @param {StoreApiStoreControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFind(requestParameters: StoreApiStoreControllerFindRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFind(requestParameters.orderDate, requestParameters.orderTime, requestParameters.name, requestParameters.tags, requestParameters.maxDistance, requestParameters.openOnly, requestParameters.orderType, requestParameters.ids, requestParameters.funnel, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store information
     * @param {StoreApiStoreControllerFindOneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFindOne(requestParameters: StoreApiStoreControllerFindOneRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFindOne(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


