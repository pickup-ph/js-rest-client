/* tslint:disable */
/* eslint-disable */
/**
 * Pickup API
 * # Authorization   Pickup API accepts one type of authentication   <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AttachedReservationPaymentEntity
 */
export interface AttachedReservationPaymentEntity {
    /**
     * Payment attach status
     * @type {string}
     * @memberof AttachedReservationPaymentEntity
     */
    'status'?: string;
    /**
     * url  for payment verify
     * @type {string}
     * @memberof AttachedReservationPaymentEntity
     */
    'redirect_url'?: string;
    /**
     * action url for 3DS card payments
     * @type {string}
     * @memberof AttachedReservationPaymentEntity
     */
    'next_action_url'?: string;
    /**
     * additional response detail
     * @type {string}
     * @memberof AttachedReservationPaymentEntity
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface AvailableReservationEntity
 */
export interface AvailableReservationEntity {
    /**
     * 
     * @type {boolean}
     * @memberof AvailableReservationEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AvailableReservationEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof AvailableReservationEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {StoreReservationClass}
     * @memberof AvailableReservationEntity
     */
    'result': StoreReservationClass;
    /**
     * 
     * @type {number}
     * @memberof AvailableReservationEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface CartDTO
 */
export interface CartDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof CartDTO
     */
    'items': Array<CartItemDTO>;
    /**
     * 
     * @type {CartDTODeliveryOption}
     * @memberof CartDTO
     */
    'delivery_option'?: CartDTODeliveryOption;
    /**
     * 
     * @type {CustomerDetailDTO}
     * @memberof CartDTO
     */
    'customer'?: CustomerDetailDTO;
    /**
     * PickupPH supported order types
     * @type {string}
     * @memberof CartDTO
     */
    'order_type': CartDTOOrderTypeEnum;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof CartDTO
     */
    'order_date'?: string;
    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof CartDTO
     */
    'order_time'?: string;
    /**
     * Promo code
     * @type {string}
     * @memberof CartDTO
     */
    'promo_code'?: string;
}

export const CartDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type CartDTOOrderTypeEnum = typeof CartDTOOrderTypeEnum[keyof typeof CartDTOOrderTypeEnum];

/**
 * Optional variable for delivery option
 * @export
 * @interface CartDTODeliveryOption
 */
export interface CartDTODeliveryOption {
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof CartDTODeliveryOption
     */
    'delivery_payment_method'?: CartDTODeliveryOptionDeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request
     * @type {string}
     * @memberof CartDTODeliveryOption
     */
    'delivery_vehicle': CartDTODeliveryOptionDeliveryVehicleEnum;
}

export const CartDTODeliveryOptionDeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type CartDTODeliveryOptionDeliveryPaymentMethodEnum = typeof CartDTODeliveryOptionDeliveryPaymentMethodEnum[keyof typeof CartDTODeliveryOptionDeliveryPaymentMethodEnum];
export const CartDTODeliveryOptionDeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type CartDTODeliveryOptionDeliveryVehicleEnum = typeof CartDTODeliveryOptionDeliveryVehicleEnum[keyof typeof CartDTODeliveryOptionDeliveryVehicleEnum];

/**
 * 
 * @export
 * @interface CartEntity
 */
export interface CartEntity {
    /**
     * 
     * @type {string}
     * @memberof CartEntity
     */
    'checkout_url': string;
    /**
     * Updates will be sent for this cart via webhook using this identifier
     * @type {string}
     * @memberof CartEntity
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CartItemDTO
 */
export interface CartItemDTO {
    /**
     * The 24 character hexadecimal string id of the item to be added or modified
     * @type {string}
     * @memberof CartItemDTO
     */
    'id': string;
    /**
     * The item quantity to be set, 0 means item is for removal
     * @type {number}
     * @memberof CartItemDTO
     */
    'quantity': number;
    /**
     * The extra option per item
     * @type {Array<string>}
     * @memberof CartItemDTO
     */
    'extras'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CategoryClass
 */
export interface CategoryClass {
    /**
     * Indicates an item to be an exclusive offering in a meal plan type order
     * @type {boolean}
     * @memberof CategoryClass
     */
    'is_exclusive': boolean;
    /**
     * Category identifier
     * @type {string}
     * @memberof CategoryClass
     */
    'category_name': string;
    /**
     * Position of the category in the menu
     * @type {number}
     * @memberof CategoryClass
     */
    'category_position': number;
    /**
     * The limit of category per day , 0 = category is not limited
     * @type {number}
     * @memberof CategoryClass
     */
    'category_limit_per_day': number;
    /**
     * Limit of category per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof CategoryClass
     */
    'category_limit_per_time_slot': Array<ItemTimeSlotClass>;
    /**
     * True if the category should be visible to the customer
     * @type {boolean}
     * @memberof CategoryClass
     */
    'visible': boolean;
}
/**
 * 
 * @export
 * @interface ConfirmReservationDTO
 */
export interface ConfirmReservationDTO {
    /**
     * Itended payment method
     * @type {string}
     * @memberof ConfirmReservationDTO
     */
    'payment_method': string;
    /**
     * Reservatio ID to confirm
     * @type {string}
     * @memberof ConfirmReservationDTO
     */
    'reservation_id': string;
}
/**
 * 
 * @export
 * @interface ConfirmReservationEntity
 */
export interface ConfirmReservationEntity {
    /**
     * Reservation ID
     * @type {string}
     * @memberof ConfirmReservationEntity
     */
    'reservation_id': string;
    /**
     * Payment redirect URL
     * @type {string}
     * @memberof ConfirmReservationEntity
     */
    'checkout_url'?: string;
    /**
     * Payment token
     * @type {string}
     * @memberof ConfirmReservationEntity
     */
    'pending_token'?: string;
    /**
     * Payment intent ID
     * @type {string}
     * @memberof ConfirmReservationEntity
     */
    'payment_id'?: string;
    /**
     * Auth required for next step, payment method is card
     * @type {string}
     * @memberof ConfirmReservationEntity
     */
    'auth'?: string;
}
/**
 * 
 * @export
 * @interface CreateReservationDTO
 */
export interface CreateReservationDTO {
    /**
     * Store ID
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'store_id': string;
    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'date': string;
    /**
     * Military time format
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'time': string;
    /**
     * Reservation type ID
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'id': string;
    /**
     * Number of seats to be reserved
     * @type {number}
     * @memberof CreateReservationDTO
     */
    'seats': number;
    /**
     * 
     * @type {CreateReservationDTOContact}
     * @memberof CreateReservationDTO
     */
    'contact': CreateReservationDTOContact;
    /**
     * Optional customer request
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'remarks'?: string;
}
/**
 * Customer/reservation contact information
 * @export
 * @interface CreateReservationDTOContact
 */
export interface CreateReservationDTOContact {
    /**
     * Customer first name
     * @type {string}
     * @memberof CreateReservationDTOContact
     */
    'first_name': string;
    /**
     * Customer last name
     * @type {string}
     * @memberof CreateReservationDTOContact
     */
    'last_name': string;
    /**
     * Valid personal or business email address
     * @type {string}
     * @memberof CreateReservationDTOContact
     */
    'email': string;
    /**
     * Valid mobile number
     * @type {string}
     * @memberof CreateReservationDTOContact
     */
    'contact_number': string;
    /**
     * Customer ID that you want us to save for you, optional so you can pass guest users as well
     * @type {string}
     * @memberof CreateReservationDTOContact
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CreateReservationEntity
 */
export interface CreateReservationEntity {
    /**
     * New reservation id
     * @type {string}
     * @memberof CreateReservationEntity
     */
    'reservation_id': string;
    /**
     * Unique reservation number, you can use this for customer reference
     * @type {string}
     * @memberof CreateReservationEntity
     */
    'reservation_number': string;
}
/**
 * 
 * @export
 * @interface CustomerAddressDTO
 */
export interface CustomerAddressDTO {
    /**
     * 
     * @type {number}
     * @memberof CustomerAddressDTO
     */
    'lng': number;
    /**
     * 
     * @type {number}
     * @memberof CustomerAddressDTO
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface CustomerDetailDTO
 */
export interface CustomerDetailDTO {
    /**
     * 
     * @type {CustomerAddressDTO}
     * @memberof CustomerDetailDTO
     */
    'address'?: CustomerAddressDTO;
    /**
     * 
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'last_name'?: string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'mobile_number'?: string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'email'?: string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CustomerQuoteDTO
 */
export interface CustomerQuoteDTO {
    /**
     * 
     * @type {CustomerAddressDTO}
     * @memberof CustomerQuoteDTO
     */
    'address': CustomerAddressDTO;
    /**
     * 
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'mobile_number': string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'email': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeliveryOptionDTO
 */
export interface DeliveryOptionDTO {
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof DeliveryOptionDTO
     */
    'delivery_payment_method'?: DeliveryOptionDTODeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request
     * @type {string}
     * @memberof DeliveryOptionDTO
     */
    'delivery_vehicle': DeliveryOptionDTODeliveryVehicleEnum;
}

export const DeliveryOptionDTODeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type DeliveryOptionDTODeliveryPaymentMethodEnum = typeof DeliveryOptionDTODeliveryPaymentMethodEnum[keyof typeof DeliveryOptionDTODeliveryPaymentMethodEnum];
export const DeliveryOptionDTODeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type DeliveryOptionDTODeliveryVehicleEnum = typeof DeliveryOptionDTODeliveryVehicleEnum[keyof typeof DeliveryOptionDTODeliveryVehicleEnum];

/**
 * 
 * @export
 * @interface DeliveryQuotationEntity
 */
export interface DeliveryQuotationEntity {
    /**
     * Quoted Delivery Fee from respective partner
     * @type {number}
     * @memberof DeliveryQuotationEntity
     */
    'delivery_fee': number;
    /**
     * Delivery Partner quotation source
     * @type {string}
     * @memberof DeliveryQuotationEntity
     */
    'partner': string;
    /**
     * Indicator for the success quotation
     * @type {boolean}
     * @memberof DeliveryQuotationEntity
     */
    'is_success': boolean;
    /**
     * Indicator for the success quotation
     * @type {Array<string>}
     * @memberof DeliveryQuotationEntity
     */
    'message'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeliveryQuotationResultEntity
 */
export interface DeliveryQuotationResultEntity {
    /**
     * 
     * @type {DeliveryQuotationEntity}
     * @memberof DeliveryQuotationResultEntity
     */
    'selected': DeliveryQuotationEntity;
    /**
     * List of active delivery partners from quotation , for quotation reference on multihailing stores
     * @type {Array<DeliveryQuotationEntity>}
     * @memberof DeliveryQuotationResultEntity
     */
    'delivery_partner_quotations'?: Array<DeliveryQuotationEntity>;
}
/**
 * 
 * @export
 * @interface ExtraGroupClass
 */
export interface ExtraGroupClass {
    /**
     * Indicates if extras within a group is REQUIRED to be added on cart with the item
     * @type {boolean}
     * @memberof ExtraGroupClass
     */
    'is_required': boolean;
    /**
     * The name of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'name': string;
    /**
     * The description of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'description': string;
    /**
     * Minimum number of extras within a group that NEEDS to be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'minimum_number': number;
    /**
     * Maximum number of extras within a group that can be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'maximum_number': number;
    /**
     * List of extras within a group
     * @type {Array<GroupSelectionClass>}
     * @memberof ExtraGroupClass
     */
    'extras'?: Array<GroupSelectionClass>;
}
/**
 * 
 * @export
 * @interface GroupSelectionClass
 */
export interface GroupSelectionClass {
    /**
     * The unique bson identifier of the extra, to be used on the create cart endpoint
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'id'?: string;
    /**
     * Nominated position of the extra in a list
     * @type {number}
     * @memberof GroupSelectionClass
     */
    'position': number;
    /**
     * Random unique identifier for extras
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'extra_code': string;
    /**
     * Pertains to the regular price of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'price': string;
    /**
     * The name of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ItemClass
 */
export interface ItemClass {
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemClass
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof ItemClass
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof ItemClass
     */
    'item_code': string;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_meal_plan'?: boolean;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof ItemClass
     */
    'item_limit_per_day'?: number;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof ItemClass
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'tags': Array<string>;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemClass
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemInventoryEntity
 */
export interface ItemInventoryEntity {
    /**
     * Number of available item quantity
     * @type {number}
     * @memberof ItemInventoryEntity
     */
    'available': number;
}
/**
 * 
 * @export
 * @interface ItemPartialClass
 */
export interface ItemPartialClass {
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemPartialClass
     */
    'id'?: string;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemPartialClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemPartialClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemPartialClass
     */
    'tags': Array<string>;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemPartialClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemTimeSlotClass
 */
export interface ItemTimeSlotClass {
    /**
     * Time-slot indicator
     * @type {string}
     * @memberof ItemTimeSlotClass
     */
    'time_slot': string;
    /**
     * Indicates the limit of purchases an item could have in a time slot
     * @type {number}
     * @memberof ItemTimeSlotClass
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ItemsEntity
 */
export interface ItemsEntity {
    /**
     * 
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemsEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<ItemPartialClass>}
     * @memberof ItemsEntity
     */
    'result': Array<ItemPartialClass>;
    /**
     * 
     * @type {number}
     * @memberof ItemsEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface LocationPointDTO
 */
export interface LocationPointDTO {
    /**
     * Maximum store delivery distance in kilometers
     * @type {number}
     * @memberof LocationPointDTO
     */
    'max_radius': number;
    /**
     * 
     * @type {number}
     * @memberof LocationPointDTO
     */
    'lng': number;
    /**
     * 
     * @type {number}
     * @memberof LocationPointDTO
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface MenuClass
 */
export interface MenuClass {
    /**
     * 
     * @type {MenuClassItem}
     * @memberof MenuClass
     */
    'item': MenuClassItem;
    /**
     * Item limit per day 0 = category is not limited
     * @type {number}
     * @memberof MenuClass
     */
    'item_limit_per_day': number;
    /**
     * To check if the item is available
     * @type {boolean}
     * @memberof MenuClass
     */
    'available': boolean;
    /**
     * True if the item should be visible to the customer , item can be available but not be visible
     * @type {boolean}
     * @memberof MenuClass
     */
    'visible': boolean;
    /**
     * Position of the item in the store menu
     * @type {number}
     * @memberof MenuClass
     */
    'order_position': number;
    /**
     * Item category name
     * @type {string}
     * @memberof MenuClass
     */
    'category': string;
    /**
     * Item limit per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClass
     */
    'item_limit_per_time_slot': Array<ItemTimeSlotClass>;
}
/**
 * Item id that will be used for cart building on /cart route
 * @export
 * @interface MenuClassItem
 */
export interface MenuClassItem {
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof MenuClassItem
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof MenuClassItem
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof MenuClassItem
     */
    'item_code': string;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_meal_plan'?: boolean;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof MenuClassItem
     */
    'item_limit_per_day'?: number;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClassItem
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof MenuClassItem
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof MenuClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof MenuClassItem
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof MenuClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof MenuClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof MenuClassItem
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'tags': Array<string>;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof MenuClassItem
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderDetailsClass
 */
export interface OrderDetailsClass {
    /**
     * Item order quantity
     * @type {number}
     * @memberof OrderDetailsClass
     */
    'quantity': number;
    /**
     * 
     * @type {OrderDetailsClassItem}
     * @memberof OrderDetailsClass
     */
    'item'?: OrderDetailsClassItem;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderDetailsClass
     */
    'id': string;
    /**
     * 
     * @type {Array<OrderExtraClass>}
     * @memberof OrderDetailsClass
     */
    'extras': Array<OrderExtraClass>;
}
/**
 * Item information
 * @export
 * @interface OrderDetailsClassItem
 */
export interface OrderDetailsClassItem {
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'regular_price': string;
}
/**
 * 
 * @export
 * @interface OrderEntity
 */
export interface OrderEntity {
    /**
     * 
     * @type {boolean}
     * @memberof OrderEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<OrderPartialClass>}
     * @memberof OrderEntity
     */
    'result': Array<OrderPartialClass>;
    /**
     * 
     * @type {number}
     * @memberof OrderEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface OrderExtraClass
 */
export interface OrderExtraClass {
    /**
     * Unique extra code
     * @type {string}
     * @memberof OrderExtraClass
     */
    'code': string;
    /**
     * Extra ID
     * @type {string}
     * @memberof OrderExtraClass
     */
    'id': string;
    /**
     * Name of the extra
     * @type {string}
     * @memberof OrderExtraClass
     */
    'name': string;
    /**
     * Indicates the regular price of the extra
     * @type {string}
     * @memberof OrderExtraClass
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface OrderItemClass
 */
export interface OrderItemClass {
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof OrderItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof OrderItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof OrderItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof OrderItemClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof OrderItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof OrderItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof OrderItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof OrderItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof OrderItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof OrderItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof OrderItemClass
     */
    'regular_price': string;
}
/**
 * 
 * @export
 * @interface OrderPartialClass
 */
export interface OrderPartialClass {
    /**
     * Order ID that will be used to search
     * @type {string}
     * @memberof OrderPartialClass
     */
    'id': string;
    /**
     * 
     * @type {OrderPartialClassStoreDetails}
     * @memberof OrderPartialClass
     */
    'store_details': OrderPartialClassStoreDetails;
    /**
     * Guest customer information
     * @type {object}
     * @memberof OrderPartialClass
     */
    'customer': object;
    /**
     * Total order amount
     * @type {number}
     * @memberof OrderPartialClass
     */
    'total_amount'?: number;
    /**
     * Delivery fee charged if order type is delivery
     * @type {string}
     * @memberof OrderPartialClass
     */
    'charged_delivery_fee': string;
    /**
     * Indicates delivery fee was paid via cash
     * @type {boolean}
     * @memberof OrderPartialClass
     */
    'delivery_paid_by_cash': boolean;
    /**
     * Promotional discount applied on amount paid
     * @type {number}
     * @memberof OrderPartialClass
     */
    'promo_discount': number;
    /**
     * Indicates where the promotional discount has been applied
     * @type {string}
     * @memberof OrderPartialClass
     */
    'promo_base': OrderPartialClassPromoBaseEnum;
    /**
     * 
     * @type {OrderPartialClassPromo}
     * @memberof OrderPartialClass
     */
    'promo': OrderPartialClassPromo;
    /**
     * Order type
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_type': OrderPartialClassOrderTypeEnum;
    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_date': string;
    /**
     * Order time filter in HH:MM format
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_time': string;
    /**
     * Order delivery address, empty if order type is pickup or curbside pickup
     * @type {string}
     * @memberof OrderPartialClass
     */
    'delivery_address': string;
    /**
     * Order status, expired means the cart was abandoned
     * @type {string}
     * @memberof OrderPartialClass
     */
    'status'?: OrderPartialClassStatusEnum;
    /**
     * Order Details
     * @type {Array<OrderDetailsClass>}
     * @memberof OrderPartialClass
     */
    'order_details': Array<OrderDetailsClass>;
    /**
     * Status update timestamps
     * @type {object}
     * @memberof OrderPartialClass
     */
    'change_timestamp': object;
    /**
     * Transaction number, this serves as pickup\'s order number
     * @type {string}
     * @memberof OrderPartialClass
     */
    'transaction_number': string;
    /**
     * Payment method used
     * @type {string}
     * @memberof OrderPartialClass
     */
    'payment_method'?: string;
    /**
     * Refunded amount, can be partial or full
     * @type {number}
     * @memberof OrderPartialClass
     */
    'refunded_amount': number;
    /**
     * Third party pickup information
     * @type {object}
     * @memberof OrderPartialClass
     */
    'pickup_details': object;
    /**
     * Tracking page for this particular order
     * @type {string}
     * @memberof OrderPartialClass
     */
    'tracking_page': string;
    /**
     * Store notes
     * @type {string}
     * @memberof OrderPartialClass
     */
    'store_notes': string;
}

export const OrderPartialClassPromoBaseEnum = {
    Cart: 'cart',
    Delivery: 'delivery'
} as const;

export type OrderPartialClassPromoBaseEnum = typeof OrderPartialClassPromoBaseEnum[keyof typeof OrderPartialClassPromoBaseEnum];
export const OrderPartialClassOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type OrderPartialClassOrderTypeEnum = typeof OrderPartialClassOrderTypeEnum[keyof typeof OrderPartialClassOrderTypeEnum];
export const OrderPartialClassStatusEnum = {
    New: 'new',
    Cancelled: 'cancelled',
    Completed: 'completed',
    Refunded: 'refunded',
    Expired: 'expired',
    PaymentFailed: 'payment_failed'
} as const;

export type OrderPartialClassStatusEnum = typeof OrderPartialClassStatusEnum[keyof typeof OrderPartialClassStatusEnum];

/**
 * Applied promo information
 * @export
 * @interface OrderPartialClassPromo
 */
export interface OrderPartialClassPromo {
    /**
     * Promo code
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'code': string;
    /**
     * Type of this promo
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'type': OrderPartialClassPromoTypeEnum;
    /**
     * Identifies order types this promo belongs to
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'applies_to': OrderPartialClassPromoAppliesToEnum;
    /**
     * Promo discount as amount deductable
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'amount_off': number;
    /**
     * Promo discount as percentage
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'percentage_off': number;
    /**
     * Promo discount for delivery fee
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'subsidized_delivery_amount': number;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'minimum_purchase': number;
    /**
     * Promo description
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'free_item_description'?: string;
    /**
     * Promo start date
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'start_date': string;
    /**
     * Promo end date
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'end_date': string;
}

export const OrderPartialClassPromoTypeEnum = {
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery',
    FreeItem: 'free_item'
} as const;

export type OrderPartialClassPromoTypeEnum = typeof OrderPartialClassPromoTypeEnum[keyof typeof OrderPartialClassPromoTypeEnum];
export const OrderPartialClassPromoAppliesToEnum = {
    Pickup: 'pickup',
    Delivery: 'delivery',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    DineIn: 'dine_in',
    MealPlan: 'meal_plan'
} as const;

export type OrderPartialClassPromoAppliesToEnum = typeof OrderPartialClassPromoAppliesToEnum[keyof typeof OrderPartialClassPromoAppliesToEnum];

/**
 * Store Details
 * @export
 * @interface OrderPartialClassStoreDetails
 */
export interface OrderPartialClassStoreDetails {
    /**
     * Store ID where order was made
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface PromoDTO
 */
export interface PromoDTO {
    /**
     * Indicates delivery payment will be paid by cash
     * @type {boolean}
     * @memberof PromoDTO
     */
    'is_cod': boolean;
    /**
     * Promo code
     * @type {string}
     * @memberof PromoDTO
     */
    'promo_code': string;
    /**
     * Store ID where the promo needs to be validated against
     * @type {string}
     * @memberof PromoDTO
     */
    'store_id': string;
    /**
     * Total price of the items in cart
     * @type {number}
     * @memberof PromoDTO
     */
    'total_amount': number;
    /**
     * Intended order type for this promo
     * @type {string}
     * @memberof PromoDTO
     */
    'order_type': PromoDTOOrderTypeEnum;
}

export const PromoDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type PromoDTOOrderTypeEnum = typeof PromoDTOOrderTypeEnum[keyof typeof PromoDTOOrderTypeEnum];

/**
 * 
 * @export
 * @interface PromoDiscountDetails
 */
export interface PromoDiscountDetails {
    /**
     * Amount to be paid before promo is applied, used as base of calculation
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'original': number;
    /**
     * Total amount after calculated promo is applied
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'applied': number;
    /**
     * Calculated promo value deducted from original price
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'total': number;
    /**
     * Base promo value, if promo type is amount_off this is Php 20.00 if type is percentage_off this is 20%
     * @type {string}
     * @memberof PromoDiscountDetails
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface PromoEntity
 */
export interface PromoEntity {
    /**
     * Promo code
     * @type {string}
     * @memberof PromoEntity
     */
    'code': string;
    /**
     * Type of this promo
     * @type {string}
     * @memberof PromoEntity
     */
    'type': PromoEntityTypeEnum;
    /**
     * Identifies order types this promo belongs to
     * @type {string}
     * @memberof PromoEntity
     */
    'applies_to': PromoEntityAppliesToEnum;
    /**
     * Promo discount as amount deductable
     * @type {number}
     * @memberof PromoEntity
     */
    'amount_off': number;
    /**
     * Promo discount as percentage
     * @type {number}
     * @memberof PromoEntity
     */
    'percentage_off': number;
    /**
     * Promo discount for delivery fee
     * @type {number}
     * @memberof PromoEntity
     */
    'subsidized_delivery_amount': number;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof PromoEntity
     */
    'minimum_purchase': number;
    /**
     * Promo description
     * @type {string}
     * @memberof PromoEntity
     */
    'free_item_description'?: string;
    /**
     * Promo start date
     * @type {string}
     * @memberof PromoEntity
     */
    'start_date': string;
    /**
     * Promo end date
     * @type {string}
     * @memberof PromoEntity
     */
    'end_date': string;
}

export const PromoEntityTypeEnum = {
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery',
    FreeItem: 'free_item'
} as const;

export type PromoEntityTypeEnum = typeof PromoEntityTypeEnum[keyof typeof PromoEntityTypeEnum];
export const PromoEntityAppliesToEnum = {
    Pickup: 'pickup',
    Delivery: 'delivery',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    DineIn: 'dine_in',
    MealPlan: 'meal_plan'
} as const;

export type PromoEntityAppliesToEnum = typeof PromoEntityAppliesToEnum[keyof typeof PromoEntityAppliesToEnum];

/**
 * 
 * @export
 * @interface PromoListResponse
 */
export interface PromoListResponse {
    /**
     * List of promos
     * @type {Array<PromoEntity>}
     * @memberof PromoListResponse
     */
    'promos': Array<PromoEntity>;
}
/**
 * 
 * @export
 * @interface QuotationRequestDTO
 */
export interface QuotationRequestDTO {
    /**
     * 
     * @type {QuotationRequestDTOCustomer}
     * @memberof QuotationRequestDTO
     */
    'customer': QuotationRequestDTOCustomer;
    /**
     * The 24 character hexadecimal string id of the store to be search for delivery availability and details
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'id': string;
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'delivery_payment_method': QuotationRequestDTODeliveryPaymentMethodEnum;
    /**
     * Customer Delivery Address String
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'address_string': string;
    /**
     * Delivery Vehicle Type for the request , null will default to motorcycle
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'delivery_vehicle': QuotationRequestDTODeliveryVehicleEnum;
    /**
     * Delivery schedule time in HH:MM format , null will default to asap
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'order_time'?: string;
    /**
     * Delivery Date, null will default to asap ISO8601 compliant date string, defaults to current server date ,
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'order_date'?: string;
}

export const QuotationRequestDTODeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type QuotationRequestDTODeliveryPaymentMethodEnum = typeof QuotationRequestDTODeliveryPaymentMethodEnum[keyof typeof QuotationRequestDTODeliveryPaymentMethodEnum];
export const QuotationRequestDTODeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type QuotationRequestDTODeliveryVehicleEnum = typeof QuotationRequestDTODeliveryVehicleEnum[keyof typeof QuotationRequestDTODeliveryVehicleEnum];

/**
 * Customer Details
 * @export
 * @interface QuotationRequestDTOCustomer
 */
export interface QuotationRequestDTOCustomer {
    /**
     * 
     * @type {CustomerAddressDTO}
     * @memberof QuotationRequestDTOCustomer
     */
    'address': CustomerAddressDTO;
    /**
     * 
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'mobile_number': string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'email': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReservationContact
 */
export interface ReservationContact {
    /**
     * Customer first name
     * @type {string}
     * @memberof ReservationContact
     */
    'first_name': string;
    /**
     * Customer last name
     * @type {string}
     * @memberof ReservationContact
     */
    'last_name': string;
    /**
     * Valid personal or business email address
     * @type {string}
     * @memberof ReservationContact
     */
    'email': string;
    /**
     * Valid mobile number
     * @type {string}
     * @memberof ReservationContact
     */
    'contact_number': string;
    /**
     * Customer ID that you want us to save for you, optional so you can pass guest users as well
     * @type {string}
     * @memberof ReservationContact
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ReservationCustomerEntity
 */
export interface ReservationCustomerEntity {
    /**
     * Customer ID that you passed to us
     * @type {string}
     * @memberof ReservationCustomerEntity
     */
    'id'?: string;
    /**
     * Customer\'s first name
     * @type {string}
     * @memberof ReservationCustomerEntity
     */
    'first_name': string;
    /**
     * Customer\'s last name
     * @type {string}
     * @memberof ReservationCustomerEntity
     */
    'last_name': string;
    /**
     * Valid email address of the customer
     * @type {string}
     * @memberof ReservationCustomerEntity
     */
    'email': string;
    /**
     * Valid mobile number of the customer
     * @type {string}
     * @memberof ReservationCustomerEntity
     */
    'contact_number': string;
}
/**
 * 
 * @export
 * @interface ReservationEntity
 */
export interface ReservationEntity {
    /**
     * 
     * @type {boolean}
     * @memberof ReservationEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReservationEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof ReservationEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<ReservationInfoEntity>}
     * @memberof ReservationEntity
     */
    'result': Array<ReservationInfoEntity>;
    /**
     * 
     * @type {number}
     * @memberof ReservationEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface ReservationInfoEntity
 */
export interface ReservationInfoEntity {
    /**
     * 
     * @type {ReservationInfoEntityContact}
     * @memberof ReservationInfoEntity
     */
    'contact': ReservationInfoEntityContact;
    /**
     * Reservation id
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'id': string;
    /**
     * Reservation status
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'status': string;
    /**
     * Reserved seats
     * @type {number}
     * @memberof ReservationInfoEntity
     */
    'seats': number;
    /**
     * Reserved date
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'date': string;
    /**
     * Reserved time in military format
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'time': string;
    /**
     * Reservation request last update timestamp
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'last_updated': string;
    /**
     * Reservation request timestamp
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'created': string;
    /**
     * 
     * @type {ReservationInfoEntityType}
     * @memberof ReservationInfoEntity
     */
    'type'?: ReservationInfoEntityType;
    /**
     * 
     * @type {ReservationInfoEntityPayment}
     * @memberof ReservationInfoEntity
     */
    'payment'?: ReservationInfoEntityPayment;
    /**
     * 
     * @type {ReservationInfoEntityStore}
     * @memberof ReservationInfoEntity
     */
    'store': ReservationInfoEntityStore;
    /**
     * Unique reservation reference number
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'reservation_number': string;
    /**
     * Customer request
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'remarks'?: string;
    /**
     * Store note
     * @type {string}
     * @memberof ReservationInfoEntity
     */
    'notes'?: string;
    /**
     * Refunded amount if reservation fee is refunded
     * @type {number}
     * @memberof ReservationInfoEntity
     */
    'refunded_amount'?: number;
}
/**
 * Customer information
 * @export
 * @interface ReservationInfoEntityContact
 */
export interface ReservationInfoEntityContact {
    /**
     * Customer ID that you passed to us
     * @type {string}
     * @memberof ReservationInfoEntityContact
     */
    'id'?: string;
    /**
     * Customer\'s first name
     * @type {string}
     * @memberof ReservationInfoEntityContact
     */
    'first_name': string;
    /**
     * Customer\'s last name
     * @type {string}
     * @memberof ReservationInfoEntityContact
     */
    'last_name': string;
    /**
     * Valid email address of the customer
     * @type {string}
     * @memberof ReservationInfoEntityContact
     */
    'email': string;
    /**
     * Valid mobile number of the customer
     * @type {string}
     * @memberof ReservationInfoEntityContact
     */
    'contact_number': string;
}
/**
 * Payment information and status
 * @export
 * @interface ReservationInfoEntityPayment
 */
export interface ReservationInfoEntityPayment {
    /**
     * Customer\'s payment reference number
     * @type {string}
     * @memberof ReservationInfoEntityPayment
     */
    'payment_id'?: string;
    /**
     * Total amount paid/to be paid for this reservation to be accepted
     * @type {number}
     * @memberof ReservationInfoEntityPayment
     */
    'amount': number;
    /**
     * Customer\'s selected payment method
     * @type {string}
     * @memberof ReservationInfoEntityPayment
     */
    'payment_method': string;
    /**
     * Customer\'s payment status
     * @type {string}
     * @memberof ReservationInfoEntityPayment
     */
    'status': string;
}
/**
 * Store information
 * @export
 * @interface ReservationInfoEntityStore
 */
export interface ReservationInfoEntityStore {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof ReservationInfoEntityStore
     */
    'delivery_distance_limit'?: number;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof ReservationInfoEntityStore
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'geocode_location'?: string;
    /**
     * Distance from location_point to Store Distance in Kilometers
     * @type {number}
     * @memberof ReservationInfoEntityStore
     */
    'distance'?: number;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof ReservationInfoEntityStore
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof ReservationInfoEntityStore
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof ReservationInfoEntityStore
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled
     * @type {boolean}
     * @memberof ReservationInfoEntityStore
     */
    'is_accepting_in_advanced_orders': boolean;
}
/**
 * Reservation type information
 * @export
 * @interface ReservationInfoEntityType
 */
export interface ReservationInfoEntityType {
    /**
     * Reservation type id
     * @type {string}
     * @memberof ReservationInfoEntityType
     */
    'id': string;
    /**
     * Reservation type name
     * @type {string}
     * @memberof ReservationInfoEntityType
     */
    'name': string;
    /**
     * Reservation type description
     * @type {string}
     * @memberof ReservationInfoEntityType
     */
    'description': string;
    /**
     * Indicates if this type of reservation is still active
     * @type {boolean}
     * @memberof ReservationInfoEntityType
     */
    'is_active': boolean;
    /**
     * Indicates the maximum seats that can be reserved, 0 means no limit
     * @type {number}
     * @memberof ReservationInfoEntityType
     */
    'limit': number;
    /**
     * Indicates the minumum required seats that can be reserved
     * @type {number}
     * @memberof ReservationInfoEntityType
     */
    'minimum': number;
    /**
     * Reservation end date, void means no end date
     * @type {string}
     * @memberof ReservationInfoEntityType
     */
    'end_date'?: string;
    /**
     * Reservation start date, void means no start date
     * @type {string}
     * @memberof ReservationInfoEntityType
     */
    'start_date'?: string;
}
/**
 * 
 * @export
 * @interface ReservationPaymentAttachDTO
 */
export interface ReservationPaymentAttachDTO {
    /**
     * Itended payment method
     * @type {string}
     * @memberof ReservationPaymentAttachDTO
     */
    'payment_method': string;
    /**
     * Reservatio ID to confirm
     * @type {string}
     * @memberof ReservationPaymentAttachDTO
     */
    'reservation_id': string;
    /**
     * Reservatio ID to confirm
     * @type {string}
     * @memberof ReservationPaymentAttachDTO
     */
    'payment_id': string;
    /**
     * Store ID to confirm
     * @type {string}
     * @memberof ReservationPaymentAttachDTO
     */
    'store_id': string;
}
/**
 * 
 * @export
 * @interface ReservationPaymentEntity
 */
export interface ReservationPaymentEntity {
    /**
     * Customer\'s payment reference number
     * @type {string}
     * @memberof ReservationPaymentEntity
     */
    'payment_id'?: string;
    /**
     * Total amount paid/to be paid for this reservation to be accepted
     * @type {number}
     * @memberof ReservationPaymentEntity
     */
    'amount': number;
    /**
     * Customer\'s selected payment method
     * @type {string}
     * @memberof ReservationPaymentEntity
     */
    'payment_method': string;
    /**
     * Customer\'s payment status
     * @type {string}
     * @memberof ReservationPaymentEntity
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ReservationSettingEntity
 */
export interface ReservationSettingEntity {
    /**
     * Reservation type id
     * @type {string}
     * @memberof ReservationSettingEntity
     */
    'id': string;
    /**
     * Reservation type name
     * @type {string}
     * @memberof ReservationSettingEntity
     */
    'name': string;
    /**
     * Reservation type description
     * @type {string}
     * @memberof ReservationSettingEntity
     */
    'description': string;
    /**
     * Indicates if this type of reservation is still active
     * @type {boolean}
     * @memberof ReservationSettingEntity
     */
    'is_active': boolean;
    /**
     * Indicates the maximum seats that can be reserved, 0 means no limit
     * @type {number}
     * @memberof ReservationSettingEntity
     */
    'limit': number;
    /**
     * Indicates the minumum required seats that can be reserved
     * @type {number}
     * @memberof ReservationSettingEntity
     */
    'minimum': number;
    /**
     * Reservation end date, void means no end date
     * @type {string}
     * @memberof ReservationSettingEntity
     */
    'end_date'?: string;
    /**
     * Reservation start date, void means no start date
     * @type {string}
     * @memberof ReservationSettingEntity
     */
    'start_date'?: string;
}
/**
 * 
 * @export
 * @interface ReservationTypeClass
 */
export interface ReservationTypeClass {
    /**
     * Type of reservation
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'type': ReservationTypeClassTypeEnum;
    /**
     * Name of reservation
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'name': string;
    /**
     * Description of reservation
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'description': string;
    /**
     * 
     * @type {ReservationTypeClassHours}
     * @memberof ReservationTypeClass
     */
    'hours': ReservationTypeClassHours;
    /**
     * Indicates the payment type
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'payment_type': ReservationTypeClassPaymentTypeEnum;
    /**
     * Max seats that can be reserved per reservation
     * @type {number}
     * @memberof ReservationTypeClass
     */
    'limit': number;
    /**
     * Min seats that can be reserved per reservation
     * @type {number}
     * @memberof ReservationTypeClass
     */
    'minimum': number;
    /**
     * 
     * @type {ReservationInfoEntityStore}
     * @memberof ReservationTypeClass
     */
    'store': ReservationInfoEntityStore;
    /**
     * ID of the reservation type
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'id': string;
    /**
     * Fee to be paid multiplied by payment type
     * @type {number}
     * @memberof ReservationTypeClass
     */
    'fee': number;
    /**
     * UI helper, this is the calculated time slots that can be reserved within the selected reservation date
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'time_slots': string;
    /**
     * Reservation end date, void means no end date
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'end_date'?: string;
    /**
     * Reservation start date, void means no start date
     * @type {string}
     * @memberof ReservationTypeClass
     */
    'start_date'?: string;
}

export const ReservationTypeClassTypeEnum = {
    Table: 'table',
    Event: 'event'
} as const;

export type ReservationTypeClassTypeEnum = typeof ReservationTypeClassTypeEnum[keyof typeof ReservationTypeClassTypeEnum];
export const ReservationTypeClassPaymentTypeEnum = {
    AllIn: 'all_in',
    PerGuest: 'per_guest'
} as const;

export type ReservationTypeClassPaymentTypeEnum = typeof ReservationTypeClassPaymentTypeEnum[keyof typeof ReservationTypeClassPaymentTypeEnum];

/**
 * List of hours per day of week that can be reserved
 * @export
 * @interface ReservationTypeClassHours
 */
export interface ReservationTypeClassHours {
    /**
     * Indicates if reservations are accepted on this day of week
     * @type {boolean}
     * @memberof ReservationTypeClassHours
     */
    'is_open': boolean;
    /**
     * Day in week
     * @type {string}
     * @memberof ReservationTypeClassHours
     */
    'day': string;
    /**
     * Indicates the minimum time of day that can be reserved
     * @type {string}
     * @memberof ReservationTypeClassHours
     */
    'opening': string;
    /**
     * Indicates the maximum time of day that can be reserved
     * @type {string}
     * @memberof ReservationTypeClassHours
     */
    'closing': string;
}
/**
 * 
 * @export
 * @interface SearchStoreDTO
 */
export interface SearchStoreDTO {
    /**
     * 
     * @type {SearchStoreDTOLocationPoint}
     * @memberof SearchStoreDTO
     */
    'location_point'?: SearchStoreDTOLocationPoint;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'order_date'?: string;
    /**
     * Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'order_time'?: string;
    /**
     * General search key name for \"store name\",\"item name\", \"item description\"
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'name'?: string;
    /**
     * Store tags filter comma separated
     * @type {Array<string>}
     * @memberof SearchStoreDTO
     */
    'tags'?: Array<string>;
    /**
     * Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
     * @type {boolean}
     * @memberof SearchStoreDTO
     */
    'open_only'?: boolean;
    /**
     * Store supported fulfillment service
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'order_type'?: SearchStoreDTOOrderTypeEnum;
    /**
     * Filter store via id
     * @type {Array<string>}
     * @memberof SearchStoreDTO
     */
    'ids'?: Array<string>;
    /**
     * Custom data-driven filters
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'funnel'?: SearchStoreDTOFunnelEnum;
    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof SearchStoreDTO
     */
    'limit'?: number;
    /**
     * The number of records to skip
     * @type {number}
     * @memberof SearchStoreDTO
     */
    'offset'?: number;
}

export const SearchStoreDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type SearchStoreDTOOrderTypeEnum = typeof SearchStoreDTOOrderTypeEnum[keyof typeof SearchStoreDTOOrderTypeEnum];
export const SearchStoreDTOFunnelEnum = {
    PopularDay: 'popular_day'
} as const;

export type SearchStoreDTOFunnelEnum = typeof SearchStoreDTOFunnelEnum[keyof typeof SearchStoreDTOFunnelEnum];

/**
 * Optional location for kilometer distance search
 * @export
 * @interface SearchStoreDTOLocationPoint
 */
export interface SearchStoreDTOLocationPoint {
    /**
     * Maximum store delivery distance in kilometers
     * @type {number}
     * @memberof SearchStoreDTOLocationPoint
     */
    'max_radius': number;
    /**
     * 
     * @type {number}
     * @memberof SearchStoreDTOLocationPoint
     */
    'lng': number;
    /**
     * 
     * @type {number}
     * @memberof SearchStoreDTOLocationPoint
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface StoreClass
 */
export interface StoreClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreClass
     */
    'delivery_distance_limit'?: number;
    /**
     * Store accepts curbside delivery
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_curbside_active': boolean;
    /**
     * Store accepts pickup order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_pickup_active': boolean;
    /**
     * Store accepts delivery order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_delivery_active': boolean;
    /**
     * Store accepts mealplan order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_meal_plan_active': boolean;
    /**
     * Store accepts dine in order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_dine_in_active': boolean;
    /**
     * Total allowed number of items purchased on a store per day
     * @type {number}
     * @memberof StoreClass
     */
    'store_item_limit_per_day': number;
    /**
     * Indicates if a store accepts and process orders any time of the day
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_open_24_hours': boolean;
    /**
     * List of dates that indicates the store as closed and will NOT accept orders
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'off_dates': Array<string>;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StoreClass
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StoreClass
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store menu grouped and ordered by category
     * @type {Array<MenuClass>}
     * @memberof StoreClass
     */
    'menu': Array<MenuClass>;
    /**
     * Available delivery payment method
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'delivery_payment_methods': Array<string>;
    /**
     * Store category list
     * @type {Array<CategoryClass>}
     * @memberof StoreClass
     */
    'categories': Array<CategoryClass>;
    /**
     * Helper for expected meal plan deliveries dates
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'meal_plan_dates': Array<string>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreClass
     */
    'geocode_location'?: string;
    /**
     * Distance from location_point to Store Distance in Kilometers
     * @type {number}
     * @memberof StoreClass
     */
    'distance'?: number;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_accepting_in_advanced_orders': boolean;
}
/**
 * 
 * @export
 * @interface StoreDetailsClass
 */
export interface StoreDetailsClass {
    /**
     * Store ID where order was made
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface StoreHoursClass
 */
export interface StoreHoursClass {
    /**
     * Indicates if the store is open on the specific day
     * @type {boolean}
     * @memberof StoreHoursClass
     */
    'is_open': boolean;
    /**
     * Day of the week 0 = Sunday, 1 = Monday , 2 = Tuesday...
     * @type {string}
     * @memberof StoreHoursClass
     */
    'day': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'opening': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'closing': string;
}
/**
 * 
 * @export
 * @interface StorePartialClass
 */
export interface StorePartialClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StorePartialClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StorePartialClass
     */
    'delivery_distance_limit'?: number;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StorePartialClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StorePartialClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StorePartialClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StorePartialClass
     */
    'geocode_location'?: string;
    /**
     * Distance from location_point to Store Distance in Kilometers
     * @type {number}
     * @memberof StorePartialClass
     */
    'distance'?: number;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StorePartialClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StorePartialClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_accepting_in_advanced_orders': boolean;
}
/**
 * 
 * @export
 * @interface StoreReservationClass
 */
export interface StoreReservationClass {
    /**
     * 
     * @type {ReservationInfoEntityStore}
     * @memberof StoreReservationClass
     */
    'store': ReservationInfoEntityStore;
    /**
     * 
     * @type {StoreReservationClassReservations}
     * @memberof StoreReservationClass
     */
    'reservations': StoreReservationClassReservations;
}
/**
 * List of reservation types this a store offers
 * @export
 * @interface StoreReservationClassReservations
 */
export interface StoreReservationClassReservations {
    /**
     * Type of reservation
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'type': StoreReservationClassReservationsTypeEnum;
    /**
     * Name of reservation
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'name': string;
    /**
     * Description of reservation
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'description': string;
    /**
     * 
     * @type {ReservationTypeClassHours}
     * @memberof StoreReservationClassReservations
     */
    'hours': ReservationTypeClassHours;
    /**
     * Indicates the payment type
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'payment_type': StoreReservationClassReservationsPaymentTypeEnum;
    /**
     * Max seats that can be reserved per reservation
     * @type {number}
     * @memberof StoreReservationClassReservations
     */
    'limit': number;
    /**
     * Min seats that can be reserved per reservation
     * @type {number}
     * @memberof StoreReservationClassReservations
     */
    'minimum': number;
    /**
     * 
     * @type {ReservationInfoEntityStore}
     * @memberof StoreReservationClassReservations
     */
    'store': ReservationInfoEntityStore;
    /**
     * ID of the reservation type
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'id': string;
    /**
     * Fee to be paid multiplied by payment type
     * @type {number}
     * @memberof StoreReservationClassReservations
     */
    'fee': number;
    /**
     * UI helper, this is the calculated time slots that can be reserved within the selected reservation date
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'time_slots': string;
    /**
     * Reservation end date, void means no end date
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'end_date'?: string;
    /**
     * Reservation start date, void means no start date
     * @type {string}
     * @memberof StoreReservationClassReservations
     */
    'start_date'?: string;
}

export const StoreReservationClassReservationsTypeEnum = {
    Table: 'table',
    Event: 'event'
} as const;

export type StoreReservationClassReservationsTypeEnum = typeof StoreReservationClassReservationsTypeEnum[keyof typeof StoreReservationClassReservationsTypeEnum];
export const StoreReservationClassReservationsPaymentTypeEnum = {
    AllIn: 'all_in',
    PerGuest: 'per_guest'
} as const;

export type StoreReservationClassReservationsPaymentTypeEnum = typeof StoreReservationClassReservationsPaymentTypeEnum[keyof typeof StoreReservationClassReservationsPaymentTypeEnum];

/**
 * 
 * @export
 * @interface StoreReservationHoursEntity
 */
export interface StoreReservationHoursEntity {
    /**
     * Indicates if reservations are accepted on this day of week
     * @type {boolean}
     * @memberof StoreReservationHoursEntity
     */
    'is_open': boolean;
    /**
     * Day in week
     * @type {string}
     * @memberof StoreReservationHoursEntity
     */
    'day': string;
    /**
     * Indicates the minimum time of day that can be reserved
     * @type {string}
     * @memberof StoreReservationHoursEntity
     */
    'opening': string;
    /**
     * Indicates the maximum time of day that can be reserved
     * @type {string}
     * @memberof StoreReservationHoursEntity
     */
    'closing': string;
}
/**
 * 
 * @export
 * @interface StoreSearchClass
 */
export interface StoreSearchClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreSearchClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreSearchClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreSearchClass
     */
    'delivery_distance_limit'?: number;
    /**
     * List of items related to name
     * @type {Array<ItemPartialClass>}
     * @memberof StoreSearchClass
     */
    'searched_items'?: Array<ItemPartialClass>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreSearchClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreSearchClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreSearchClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreSearchClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreSearchClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreSearchClass
     */
    'geocode_location'?: string;
    /**
     * Distance from location_point to Store Distance in Kilometers
     * @type {number}
     * @memberof StoreSearchClass
     */
    'distance'?: number;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreSearchClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreSearchClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreSearchClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled
     * @type {boolean}
     * @memberof StoreSearchClass
     */
    'is_accepting_in_advanced_orders': boolean;
}
/**
 * 
 * @export
 * @interface StoresEntity
 */
export interface StoresEntity {
    /**
     * 
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof StoresEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<StoreSearchClass>}
     * @memberof StoresEntity
     */
    'result': Array<StoreSearchClass>;
    /**
     * 
     * @type {number}
     * @memberof StoresEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface ValidPromoEntity
 */
export interface ValidPromoEntity {
    /**
     * Type of this promo
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'type': ValidPromoEntityTypeEnum;
    /**
     * 
     * @type {ValidPromoEntityPromo}
     * @memberof ValidPromoEntity
     */
    'promo'?: ValidPromoEntityPromo;
    /**
     * Calculated discount for delivery fee
     * @type {number}
     * @memberof ValidPromoEntity
     */
    'delivery_discount': number;
    /**
     * Promo description
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'description'?: string;
    /**
     * Promo expiry
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'end_date'?: string;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof ValidPromoEntity
     */
    'minimum_purchase'?: number;
}

export const ValidPromoEntityTypeEnum = {
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery',
    FreeItem: 'free_item'
} as const;

export type ValidPromoEntityTypeEnum = typeof ValidPromoEntityTypeEnum[keyof typeof ValidPromoEntityTypeEnum];

/**
 * Calculated discount base on total amount
 * @export
 * @interface ValidPromoEntityPromo
 */
export interface ValidPromoEntityPromo {
    /**
     * Amount to be paid before promo is applied, used as base of calculation
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'original': number;
    /**
     * Total amount after calculated promo is applied
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'applied': number;
    /**
     * Calculated promo value deducted from original price
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'total': number;
    /**
     * Base promo value, if promo type is amount_off this is Php 20.00 if type is percentage_off this is 20%
     * @type {string}
     * @memberof ValidPromoEntityPromo
     */
    'value': string;
}

/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate: async (cartDTO: CartDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDTO' is not null or undefined
            assertParamExists('cartControllerCreate', 'cartDTO', cartDTO)
            const localVarPath = `/v1/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerCreate(cartDTO: CartDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerCreate(cartDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate(cartDTO: CartDTO, options?: any): AxiosPromise<CartEntity> {
            return localVarFp.cartControllerCreate(cartDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cartControllerCreate operation in CartApi.
 * @export
 * @interface CartApiCartControllerCreateRequest
 */
export interface CartApiCartControllerCreateRequest {
    /**
     * 
     * @type {CartDTO}
     * @memberof CartApiCartControllerCreate
     */
    readonly cartDTO: CartDTO
}

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Create cart
     * @param {CartApiCartControllerCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerCreate(requestParameters: CartApiCartControllerCreateRequest, options?: AxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerCreate(requestParameters.cartDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo(options?: any): AxiosPromise<object> {
            return localVarFp.appControllerGetServerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get server information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetServerInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeliveryApi - axios parameter creator
 * @export
 */
export const DeliveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryControllerGetQuotation: async (quotationRequestDTO: QuotationRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quotationRequestDTO' is not null or undefined
            assertParamExists('deliveryControllerGetQuotation', 'quotationRequestDTO', quotationRequestDTO)
            const localVarPath = `/v1/delivery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quotationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeliveryApi - functional programming interface
 * @export
 */
export const DeliveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeliveryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryControllerGetQuotation(quotationRequestDTO: QuotationRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryQuotationResultEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryControllerGetQuotation(quotationRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeliveryApi - factory interface
 * @export
 */
export const DeliveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeliveryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryControllerGetQuotation(quotationRequestDTO: QuotationRequestDTO, options?: any): AxiosPromise<DeliveryQuotationResultEntity> {
            return localVarFp.deliveryControllerGetQuotation(quotationRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deliveryControllerGetQuotation operation in DeliveryApi.
 * @export
 * @interface DeliveryApiDeliveryControllerGetQuotationRequest
 */
export interface DeliveryApiDeliveryControllerGetQuotationRequest {
    /**
     * 
     * @type {QuotationRequestDTO}
     * @memberof DeliveryApiDeliveryControllerGetQuotation
     */
    readonly quotationRequestDTO: QuotationRequestDTO
}

/**
 * DeliveryApi - object-oriented interface
 * @export
 * @class DeliveryApi
 * @extends {BaseAPI}
 */
export class DeliveryApi extends BaseAPI {
    /**
     * 
     * @summary Get Quotation
     * @param {DeliveryApiDeliveryControllerGetQuotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeliveryApi
     */
    public deliveryControllerGetQuotation(requestParameters: DeliveryApiDeliveryControllerGetQuotationRequest, options?: AxiosRequestConfig) {
        return DeliveryApiFp(this.configuration).deliveryControllerGetQuotation(requestParameters.quotationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId: async (id: string, storeId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerAggregateId', 'id', id)
            const localVarPath = `/v1/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch: async (name?: string, storeId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity: async (id: string, orderDate?: string, orderTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerGetSoldQuantity', 'id', id)
            const localVarPath = `/v1/item/{id}/stock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateId(id: string, storeId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateId(id, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateSearch(name, storeId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemInventoryEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerGetSoldQuantity(id, orderDate, orderTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId(id: string, storeId?: string, options?: any): AxiosPromise<ItemClass> {
            return localVarFp.itemControllerAggregateId(id, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ItemsEntity> {
            return localVarFp.itemControllerAggregateSearch(name, storeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: any): AxiosPromise<ItemInventoryEntity> {
            return localVarFp.itemControllerGetSoldQuantity(id, orderDate, orderTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for itemControllerAggregateId operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateIdRequest
 */
export interface ItemApiItemControllerAggregateIdRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly id: string

    /**
     * ID of store
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly storeId?: string
}

/**
 * Request parameters for itemControllerAggregateSearch operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateSearchRequest
 */
export interface ItemApiItemControllerAggregateSearchRequest {
    /**
     * Item name search key, part of full name
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly name?: string

    /**
     * Filter items via store ID
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly storeId?: string

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly offset?: number
}

/**
 * Request parameters for itemControllerGetSoldQuantity operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerGetSoldQuantityRequest
 */
export interface ItemApiItemControllerGetSoldQuantityRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly id: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderDate?: string

    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderTime?: string
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Get item data
     * @param {ItemApiItemControllerAggregateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateId(requestParameters: ItemApiItemControllerAggregateIdRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateId(requestParameters.id, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search items by name
     * @param {ItemApiItemControllerAggregateSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateSearch(requestParameters: ItemApiItemControllerAggregateSearchRequest = {}, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateSearch(requestParameters.name, requestParameters.storeId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get inventory of an item
     * @param {ItemApiItemControllerGetSoldQuantityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerGetSoldQuantity(requestParameters: ItemApiItemControllerGetSoldQuantityRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerGetSoldQuantity(requestParameters.id, requestParameters.orderDate, requestParameters.orderTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Order type
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFind: async (id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersControllerFind', 'id', id)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (maxOrderDate !== undefined) {
                localVarQueryParameter['max_order_date'] = maxOrderDate;
            }

            if (minOrderDate !== undefined) {
                localVarQueryParameter['min_order_date'] = minOrderDate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Order type
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersControllerFind(id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersControllerFind(id, maxOrderDate, minOrderDate, status, orderType, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'} [orderType] Order type
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFind(id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup', limit?: number, offset?: number, options?: any): AxiosPromise<OrderEntity> {
            return localVarFp.ordersControllerFind(id, maxOrderDate, minOrderDate, status, orderType, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ordersControllerFind operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersControllerFindRequest
 */
export interface OrdersApiOrdersControllerFindRequest {
    /**
     * Customer ID that you passed to us
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly id: string

    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly maxOrderDate?: string

    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly minOrderDate?: string

    /**
     * Order status filter
     * @type {'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly status?: 'new' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed'

    /**
     * Order type
     * @type {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup'

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly offset?: number
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Get customer order history
     * @param {OrdersApiOrdersControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersControllerFind(requestParameters: OrdersApiOrdersControllerFindRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersControllerFind(requestParameters.id, requestParameters.maxOrderDate, requestParameters.minOrderDate, requestParameters.status, requestParameters.orderType, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromoApi - axios parameter creator
 * @export
 */
export const PromoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerGetPromosByStore: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('promoControllerGetPromosByStore', 'storeId', storeId)
            const localVarPath = `/v1/promo/{store_id}`
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerValidatePromo: async (promoDTO: PromoDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoDTO' is not null or undefined
            assertParamExists('promoControllerValidatePromo', 'promoDTO', promoDTO)
            const localVarPath = `/v1/promo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromoApi - functional programming interface
 * @export
 */
export const PromoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerGetPromosByStore(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerGetPromosByStore(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerValidatePromo(promoDTO: PromoDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidPromoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerValidatePromo(promoDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromoApi - factory interface
 * @export
 */
export const PromoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerGetPromosByStore(storeId: string, options?: any): AxiosPromise<PromoListResponse> {
            return localVarFp.promoControllerGetPromosByStore(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerValidatePromo(promoDTO: PromoDTO, options?: any): AxiosPromise<ValidPromoEntity> {
            return localVarFp.promoControllerValidatePromo(promoDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for promoControllerGetPromosByStore operation in PromoApi.
 * @export
 * @interface PromoApiPromoControllerGetPromosByStoreRequest
 */
export interface PromoApiPromoControllerGetPromosByStoreRequest {
    /**
     * Store ID of the list of promos you want to fetch
     * @type {string}
     * @memberof PromoApiPromoControllerGetPromosByStore
     */
    readonly storeId: string
}

/**
 * Request parameters for promoControllerValidatePromo operation in PromoApi.
 * @export
 * @interface PromoApiPromoControllerValidatePromoRequest
 */
export interface PromoApiPromoControllerValidatePromoRequest {
    /**
     * 
     * @type {PromoDTO}
     * @memberof PromoApiPromoControllerValidatePromo
     */
    readonly promoDTO: PromoDTO
}

/**
 * PromoApi - object-oriented interface
 * @export
 * @class PromoApi
 * @extends {BaseAPI}
 */
export class PromoApi extends BaseAPI {
    /**
     * 
     * @summary Get list of promo per store
     * @param {PromoApiPromoControllerGetPromosByStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerGetPromosByStore(requestParameters: PromoApiPromoControllerGetPromosByStoreRequest, options?: AxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerGetPromosByStore(requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate promo and get calculated result
     * @param {PromoApiPromoControllerValidatePromoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerValidatePromo(requestParameters: PromoApiPromoControllerValidatePromoRequest, options?: AxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerValidatePromo(requestParameters.promoDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReservationBetaApi - axios parameter creator
 * @export
 */
export const ReservationBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach Reservation Payment
         * @param {ReservationPaymentAttachDTO} reservationPaymentAttachDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerAttachPayment: async (reservationPaymentAttachDTO: ReservationPaymentAttachDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationPaymentAttachDTO' is not null or undefined
            assertParamExists('reservationControllerAttachPayment', 'reservationPaymentAttachDTO', reservationPaymentAttachDTO)
            const localVarPath = `/v1/reservation/attach-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reservationPaymentAttachDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm reservation
         * @param {ConfirmReservationDTO} confirmReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerConfirmReservation: async (confirmReservationDTO: ConfirmReservationDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmReservationDTO' is not null or undefined
            assertParamExists('reservationControllerConfirmReservation', 'confirmReservationDTO', confirmReservationDTO)
            const localVarPath = `/v1/reservation/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmReservationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create reservation request
         * @param {CreateReservationDTO} createReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerCreateReservation: async (createReservationDTO: CreateReservationDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createReservationDTO' is not null or undefined
            assertParamExists('reservationControllerCreateReservation', 'createReservationDTO', createReservationDTO)
            const localVarPath = `/v1/reservation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReservationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Reservation History
         * @param {string} id Customer ID that you passed to us
         * @param {'pending' | 'new' | 'accepted' | 'canceled' | 'completed'} [status] Reservation status filter
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetReservationHistory: async (id: string, status?: 'pending' | 'new' | 'accepted' | 'canceled' | 'completed', limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationControllerGetReservationHistory', 'id', id)
            const localVarPath = `/v1/reservation/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get reservation status and information
         * @param {string} reservationId Reservation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetReservationStatus: async (reservationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('reservationControllerGetReservationStatus', 'reservationId', reservationId)
            const localVarPath = `/v1/reservation/{reservation_id}`
                .replace(`{${"reservation_id"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get reservation type information
         * @param {string} id Reservation type id
         * @param {string} date Intended date to reserve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetReservationTypeInfo: async (id: string, date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationControllerGetReservationTypeInfo', 'id', id)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('reservationControllerGetReservationTypeInfo', 'date', date)
            const localVarPath = `/v1/reservation/type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store list that offers reservations
         * @param {string} seats Intended number of seats to reserve
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetStoresWithReservations: async (seats: string, date: string, time: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seats' is not null or undefined
            assertParamExists('reservationControllerGetStoresWithReservations', 'seats', seats)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('reservationControllerGetStoresWithReservations', 'date', date)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('reservationControllerGetStoresWithReservations', 'time', time)
            const localVarPath = `/v1/reservation/store/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (seats !== undefined) {
                localVarQueryParameter['seats'] = seats;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationBetaApi - functional programming interface
 * @export
 */
export const ReservationBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach Reservation Payment
         * @param {ReservationPaymentAttachDTO} reservationPaymentAttachDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerAttachPayment(reservationPaymentAttachDTO: ReservationPaymentAttachDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachedReservationPaymentEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerAttachPayment(reservationPaymentAttachDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirm reservation
         * @param {ConfirmReservationDTO} confirmReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerConfirmReservation(confirmReservationDTO: ConfirmReservationDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmReservationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerConfirmReservation(confirmReservationDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create reservation request
         * @param {CreateReservationDTO} createReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerCreateReservation(createReservationDTO: CreateReservationDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateReservationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerCreateReservation(createReservationDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Reservation History
         * @param {string} id Customer ID that you passed to us
         * @param {'pending' | 'new' | 'accepted' | 'canceled' | 'completed'} [status] Reservation status filter
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerGetReservationHistory(id: string, status?: 'pending' | 'new' | 'accepted' | 'canceled' | 'completed', limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerGetReservationHistory(id, status, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get reservation status and information
         * @param {string} reservationId Reservation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerGetReservationStatus(reservationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationInfoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerGetReservationStatus(reservationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get reservation type information
         * @param {string} id Reservation type id
         * @param {string} date Intended date to reserve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerGetReservationTypeInfo(id: string, date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReservationTypeClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerGetReservationTypeInfo(id, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store list that offers reservations
         * @param {string} seats Intended number of seats to reserve
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerGetStoresWithReservations(seats: string, date: string, time: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableReservationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerGetStoresWithReservations(seats, date, time, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReservationBetaApi - factory interface
 * @export
 */
export const ReservationBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationBetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach Reservation Payment
         * @param {ReservationPaymentAttachDTO} reservationPaymentAttachDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerAttachPayment(reservationPaymentAttachDTO: ReservationPaymentAttachDTO, options?: any): AxiosPromise<AttachedReservationPaymentEntity> {
            return localVarFp.reservationControllerAttachPayment(reservationPaymentAttachDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm reservation
         * @param {ConfirmReservationDTO} confirmReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerConfirmReservation(confirmReservationDTO: ConfirmReservationDTO, options?: any): AxiosPromise<ConfirmReservationEntity> {
            return localVarFp.reservationControllerConfirmReservation(confirmReservationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create reservation request
         * @param {CreateReservationDTO} createReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerCreateReservation(createReservationDTO: CreateReservationDTO, options?: any): AxiosPromise<CreateReservationEntity> {
            return localVarFp.reservationControllerCreateReservation(createReservationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Reservation History
         * @param {string} id Customer ID that you passed to us
         * @param {'pending' | 'new' | 'accepted' | 'canceled' | 'completed'} [status] Reservation status filter
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetReservationHistory(id: string, status?: 'pending' | 'new' | 'accepted' | 'canceled' | 'completed', limit?: number, offset?: number, options?: any): AxiosPromise<ReservationEntity> {
            return localVarFp.reservationControllerGetReservationHistory(id, status, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get reservation status and information
         * @param {string} reservationId Reservation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetReservationStatus(reservationId: string, options?: any): AxiosPromise<ReservationInfoEntity> {
            return localVarFp.reservationControllerGetReservationStatus(reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get reservation type information
         * @param {string} id Reservation type id
         * @param {string} date Intended date to reserve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetReservationTypeInfo(id: string, date: string, options?: any): AxiosPromise<ReservationTypeClass> {
            return localVarFp.reservationControllerGetReservationTypeInfo(id, date, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store list that offers reservations
         * @param {string} seats Intended number of seats to reserve
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetStoresWithReservations(seats: string, date: string, time: string, limit?: number, offset?: number, options?: any): AxiosPromise<AvailableReservationEntity> {
            return localVarFp.reservationControllerGetStoresWithReservations(seats, date, time, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reservationControllerAttachPayment operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerAttachPaymentRequest
 */
export interface ReservationBetaApiReservationControllerAttachPaymentRequest {
    /**
     * 
     * @type {ReservationPaymentAttachDTO}
     * @memberof ReservationBetaApiReservationControllerAttachPayment
     */
    readonly reservationPaymentAttachDTO: ReservationPaymentAttachDTO
}

/**
 * Request parameters for reservationControllerConfirmReservation operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerConfirmReservationRequest
 */
export interface ReservationBetaApiReservationControllerConfirmReservationRequest {
    /**
     * 
     * @type {ConfirmReservationDTO}
     * @memberof ReservationBetaApiReservationControllerConfirmReservation
     */
    readonly confirmReservationDTO: ConfirmReservationDTO
}

/**
 * Request parameters for reservationControllerCreateReservation operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerCreateReservationRequest
 */
export interface ReservationBetaApiReservationControllerCreateReservationRequest {
    /**
     * 
     * @type {CreateReservationDTO}
     * @memberof ReservationBetaApiReservationControllerCreateReservation
     */
    readonly createReservationDTO: CreateReservationDTO
}

/**
 * Request parameters for reservationControllerGetReservationHistory operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerGetReservationHistoryRequest
 */
export interface ReservationBetaApiReservationControllerGetReservationHistoryRequest {
    /**
     * Customer ID that you passed to us
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetReservationHistory
     */
    readonly id: string

    /**
     * Reservation status filter
     * @type {'pending' | 'new' | 'accepted' | 'canceled' | 'completed'}
     * @memberof ReservationBetaApiReservationControllerGetReservationHistory
     */
    readonly status?: 'pending' | 'new' | 'accepted' | 'canceled' | 'completed'

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ReservationBetaApiReservationControllerGetReservationHistory
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ReservationBetaApiReservationControllerGetReservationHistory
     */
    readonly offset?: number
}

/**
 * Request parameters for reservationControllerGetReservationStatus operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerGetReservationStatusRequest
 */
export interface ReservationBetaApiReservationControllerGetReservationStatusRequest {
    /**
     * Reservation id
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetReservationStatus
     */
    readonly reservationId: string
}

/**
 * Request parameters for reservationControllerGetReservationTypeInfo operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerGetReservationTypeInfoRequest
 */
export interface ReservationBetaApiReservationControllerGetReservationTypeInfoRequest {
    /**
     * Reservation type id
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetReservationTypeInfo
     */
    readonly id: string

    /**
     * Intended date to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetReservationTypeInfo
     */
    readonly date: string
}

/**
 * Request parameters for reservationControllerGetStoresWithReservations operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerGetStoresWithReservationsRequest
 */
export interface ReservationBetaApiReservationControllerGetStoresWithReservationsRequest {
    /**
     * Intended number of seats to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly seats: string

    /**
     * Intended date to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly date: string

    /**
     * Intended time to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly time: string

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly offset?: number
}

/**
 * ReservationBetaApi - object-oriented interface
 * @export
 * @class ReservationBetaApi
 * @extends {BaseAPI}
 */
export class ReservationBetaApi extends BaseAPI {
    /**
     * 
     * @summary Attach Reservation Payment
     * @param {ReservationBetaApiReservationControllerAttachPaymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerAttachPayment(requestParameters: ReservationBetaApiReservationControllerAttachPaymentRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerAttachPayment(requestParameters.reservationPaymentAttachDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm reservation
     * @param {ReservationBetaApiReservationControllerConfirmReservationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerConfirmReservation(requestParameters: ReservationBetaApiReservationControllerConfirmReservationRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerConfirmReservation(requestParameters.confirmReservationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create reservation request
     * @param {ReservationBetaApiReservationControllerCreateReservationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerCreateReservation(requestParameters: ReservationBetaApiReservationControllerCreateReservationRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerCreateReservation(requestParameters.createReservationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Reservation History
     * @param {ReservationBetaApiReservationControllerGetReservationHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerGetReservationHistory(requestParameters: ReservationBetaApiReservationControllerGetReservationHistoryRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerGetReservationHistory(requestParameters.id, requestParameters.status, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get reservation status and information
     * @param {ReservationBetaApiReservationControllerGetReservationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerGetReservationStatus(requestParameters: ReservationBetaApiReservationControllerGetReservationStatusRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerGetReservationStatus(requestParameters.reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get reservation type information
     * @param {ReservationBetaApiReservationControllerGetReservationTypeInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerGetReservationTypeInfo(requestParameters: ReservationBetaApiReservationControllerGetReservationTypeInfoRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerGetReservationTypeInfo(requestParameters.id, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store list that offers reservations
     * @param {ReservationBetaApiReservationControllerGetStoresWithReservationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerGetStoresWithReservations(requestParameters: ReservationBetaApiReservationControllerGetStoresWithReservationsRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerGetStoresWithReservations(requestParameters.seats, requestParameters.date, requestParameters.time, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find store
         * @param {SearchStoreDTO} searchStoreDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind: async (searchStoreDTO: SearchStoreDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchStoreDTO' is not null or undefined
            assertParamExists('storeControllerFind', 'searchStoreDTO', searchStoreDTO)
            const localVarPath = `/v1/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchStoreDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerFindOne', 'id', id)
            const localVarPath = `/v1/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find store
         * @param {SearchStoreDTO} searchStoreDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFind(searchStoreDTO: SearchStoreDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFind(searchStoreDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Find store
         * @param {SearchStoreDTO} searchStoreDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind(searchStoreDTO: SearchStoreDTO, options?: any): AxiosPromise<StoresEntity> {
            return localVarFp.storeControllerFind(searchStoreDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne(id: string, options?: any): AxiosPromise<StoreClass> {
            return localVarFp.storeControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeControllerFind operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindRequest
 */
export interface StoreApiStoreControllerFindRequest {
    /**
     * 
     * @type {SearchStoreDTO}
     * @memberof StoreApiStoreControllerFind
     */
    readonly searchStoreDTO: SearchStoreDTO
}

/**
 * Request parameters for storeControllerFindOne operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindOneRequest
 */
export interface StoreApiStoreControllerFindOneRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFindOne
     */
    readonly id: string
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Find store
     * @param {StoreApiStoreControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFind(requestParameters: StoreApiStoreControllerFindRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFind(requestParameters.searchStoreDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store information
     * @param {StoreApiStoreControllerFindOneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFindOne(requestParameters: StoreApiStoreControllerFindOneRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFindOne(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


