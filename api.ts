/* tslint:disable */
/* eslint-disable */
/**
 * Pickup API
 * # Authorization   Pickup API accepts one type of authentication   <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdditionalCharge
 */
export interface AdditionalCharge {
    /**
     * Additional charge classification
     * @type {string}
     * @memberof AdditionalCharge
     */
    'name': string;
    /**
     * Status of additional charge
     * @type {boolean}
     * @memberof AdditionalCharge
     */
    'active': boolean;
    /**
     * Additional charge type values can be amount_charge , percent_charge
     * @type {string}
     * @memberof AdditionalCharge
     */
    'type': AdditionalChargeTypeEnum;
    /**
     * This number can be by percent or amount determined by type field to compute the additional charge required by the store , example (total_amount + 100)
     * @type {number}
     * @memberof AdditionalCharge
     */
    'factor': number;
}

export const AdditionalChargeTypeEnum = {
    AmountCharge: 'amount_charge',
    PercentCharge: 'percent_charge'
} as const;

export type AdditionalChargeTypeEnum = typeof AdditionalChargeTypeEnum[keyof typeof AdditionalChargeTypeEnum];

/**
 * 
 * @export
 * @interface AvailableReservationEntity
 */
export interface AvailableReservationEntity {
    /**
     * Indicates if there is a page after the current one
     * @type {boolean}
     * @memberof AvailableReservationEntity
     */
    'has_next_page': boolean;
    /**
     * Indicates if there is a page before the current one
     * @type {boolean}
     * @memberof AvailableReservationEntity
     */
    'has_prev_page': boolean;
    /**
     * Total number of pages according to limit and result
     * @type {number}
     * @memberof AvailableReservationEntity
     */
    'total_pages': number;
    /**
     * Total number of records found against the query
     * @type {number}
     * @memberof AvailableReservationEntity
     */
    'total_records': number;
    /**
     * 
     * @type {Array<StoreReservationClass>}
     * @memberof AvailableReservationEntity
     */
    'result': Array<StoreReservationClass>;
    /**
     * Indicates current page
     * @type {number}
     * @memberof AvailableReservationEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface CartAdditionalCharge
 */
export interface CartAdditionalCharge {
    /**
     * Additional charge classification
     * @type {string}
     * @memberof CartAdditionalCharge
     */
    'name': string;
    /**
     * Additional charge type values can be amount_charge , percent_charge
     * @type {string}
     * @memberof CartAdditionalCharge
     */
    'type': CartAdditionalChargeTypeEnum;
    /**
     * Computed additional charge amount
     * @type {number}
     * @memberof CartAdditionalCharge
     */
    'amount': number;
}

export const CartAdditionalChargeTypeEnum = {
    AmountCharge: 'amount_charge',
    PercentCharge: 'percent_charge'
} as const;

export type CartAdditionalChargeTypeEnum = typeof CartAdditionalChargeTypeEnum[keyof typeof CartAdditionalChargeTypeEnum];

/**
 * 
 * @export
 * @interface CartAdditionalChargesEntity
 */
export interface CartAdditionalChargesEntity {
    /**
     * Computed total additional charges
     * @type {number}
     * @memberof CartAdditionalChargesEntity
     */
    'total_additional_charges': number;
    /**
     * Computed total cart amount after additional charges
     * @type {number}
     * @memberof CartAdditionalChargesEntity
     */
    'total_after_charges': number;
    /**
     * Additional charges breakdown used to calculate total_additional_charges
     * @type {Array<CartAdditionalCharge>}
     * @memberof CartAdditionalChargesEntity
     */
    'charges_breakdown': Array<CartAdditionalCharge>;
}
/**
 * 
 * @export
 * @interface CartDTO
 */
export interface CartDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof CartDTO
     */
    'items': Array<CartItemDTO>;
    /**
     * 
     * @type {CartDTODeliveryOption}
     * @memberof CartDTO
     */
    'delivery_option'?: CartDTODeliveryOption;
    /**
     * 
     * @type {CartDTOCurbsidePickupOption}
     * @memberof CartDTO
     */
    'curbside_pickup_option'?: CartDTOCurbsidePickupOption;
    /**
     * 
     * @type {CartDTOThirdPartyPickupOption}
     * @memberof CartDTO
     */
    'third_party_pickup_option'?: CartDTOThirdPartyPickupOption;
    /**
     * 
     * @type {CartDTOCustomer}
     * @memberof CartDTO
     */
    'customer'?: CartDTOCustomer;
    /**
     * PickupPH supported order types, meal plan will be automatically changed to delivery (if not selected)
     * @type {string}
     * @memberof CartDTO
     */
    'order_type': CartDTOOrderTypeEnum;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof CartDTO
     */
    'order_date'?: string;
    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot). You can explicitly state that you want current time, just pass asap_order_time string
     * @type {string}
     * @memberof CartDTO
     */
    'order_time'?: string;
    /**
     * Promo code
     * @type {string}
     * @memberof CartDTO
     */
    'promo_code'?: string;
    /**
     * Optional for partner\'s that wishes to use their own checkout form/ui
     * @type {string}
     * @memberof CartDTO
     */
    'payment_method'?: CartDTOPaymentMethodEnum;
}

export const CartDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    Digital: 'digital',
    Reservation: 'reservation'
} as const;

export type CartDTOOrderTypeEnum = typeof CartDTOOrderTypeEnum[keyof typeof CartDTOOrderTypeEnum];
export const CartDTOPaymentMethodEnum = {
    Card: 'card',
    Gcash: 'gcash',
    GrabPay: 'grab_pay'
} as const;

export type CartDTOPaymentMethodEnum = typeof CartDTOPaymentMethodEnum[keyof typeof CartDTOPaymentMethodEnum];

/**
 * Optional variable for curbside pickup order type
 * @export
 * @interface CartDTOCurbsidePickupOption
 */
export interface CartDTOCurbsidePickupOption {
    /**
     * Vehicle make
     * @type {string}
     * @memberof CartDTOCurbsidePickupOption
     */
    'vehicle_make': string;
    /**
     * Vehicle color
     * @type {string}
     * @memberof CartDTOCurbsidePickupOption
     */
    'vehicle_color': string;
    /**
     * Vehicle plate number
     * @type {string}
     * @memberof CartDTOCurbsidePickupOption
     */
    'vehicle_plate_number': string;
}
/**
 * The customer\'s information
 * @export
 * @interface CartDTOCustomer
 */
export interface CartDTOCustomer {
    /**
     * 
     * @type {CustomerDetailDTOAddress}
     * @memberof CartDTOCustomer
     */
    'address'?: CustomerDetailDTOAddress;
    /**
     * The customer first name
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'first_name': string;
    /**
     * The customer last name
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'mobile_number': string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'email': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'id': string;
}
/**
 * Optional variable for delivery order type
 * @export
 * @interface CartDTODeliveryOption
 */
export interface CartDTODeliveryOption {
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof CartDTODeliveryOption
     */
    'delivery_payment_method'?: CartDTODeliveryOptionDeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request
     * @type {string}
     * @memberof CartDTODeliveryOption
     */
    'delivery_vehicle'?: CartDTODeliveryOptionDeliveryVehicleEnum;
}

export const CartDTODeliveryOptionDeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type CartDTODeliveryOptionDeliveryPaymentMethodEnum = typeof CartDTODeliveryOptionDeliveryPaymentMethodEnum[keyof typeof CartDTODeliveryOptionDeliveryPaymentMethodEnum];
export const CartDTODeliveryOptionDeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type CartDTODeliveryOptionDeliveryVehicleEnum = typeof CartDTODeliveryOptionDeliveryVehicleEnum[keyof typeof CartDTODeliveryOptionDeliveryVehicleEnum];

/**
 * Optional variable for third party pickup order type
 * @export
 * @interface CartDTOThirdPartyPickupOption
 */
export interface CartDTOThirdPartyPickupOption {
    /**
     * The customer first name
     * @type {string}
     * @memberof CartDTOThirdPartyPickupOption
     */
    'first_name': string;
    /**
     * The customer last name
     * @type {string}
     * @memberof CartDTOThirdPartyPickupOption
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CartDTOThirdPartyPickupOption
     */
    'mobile_number': string;
}
/**
 * 
 * @export
 * @interface CartEntity
 */
export interface CartEntity {
    /**
     * Checkout with summary and payment options, use this to show users the payment summary
     * @type {string}
     * @memberof CartEntity
     */
    'checkout_url': string;
    /**
     * Updates will be sent for this cart via webhook using this identifier
     * @type {string}
     * @memberof CartEntity
     */
    'id': string;
    /**
     * Checkout flow, this handles redirects for you, use this if you are using your own checkout form and summary
     * @type {string}
     * @memberof CartEntity
     */
    'redirect': string;
}
/**
 * 
 * @export
 * @interface CartItemDTO
 */
export interface CartItemDTO {
    /**
     * The 24 character hexadecimal string id of the item to be added or modified
     * @type {string}
     * @memberof CartItemDTO
     */
    'id': string;
    /**
     * The item quantity to be set, 0 means item is for removal
     * @type {number}
     * @memberof CartItemDTO
     */
    'quantity': number;
    /**
     * The extra option per item
     * @type {Array<string>}
     * @memberof CartItemDTO
     */
    'extras'?: Array<string>;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof CartItemDTO
     */
    'order_date'?: string;
}
/**
 * 
 * @export
 * @interface CategoryClass
 */
export interface CategoryClass {
    /**
     * Indicates an item to be an exclusive offering in a meal plan type order
     * @type {boolean}
     * @memberof CategoryClass
     */
    'is_exclusive': boolean;
    /**
     * Category identifier
     * @type {string}
     * @memberof CategoryClass
     */
    'category_name': string;
    /**
     * Position of the category in the menu
     * @type {number}
     * @memberof CategoryClass
     */
    'category_position': number;
    /**
     * The limit of category per day , 0 = category is not limited
     * @type {number}
     * @memberof CategoryClass
     */
    'category_limit_per_day': number;
    /**
     * Limit of category per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof CategoryClass
     */
    'category_limit_per_time_slot': Array<ItemTimeSlotClass>;
    /**
     * True if the category should be visible to the customer
     * @type {boolean}
     * @memberof CategoryClass
     */
    'visible': boolean;
    /**
     * Indicates available stock at the time of pulling the store data
     * @type {number}
     * @memberof CategoryClass
     */
    'stock': number;
}
/**
 * 
 * @export
 * @interface ComputeAddtionalChargeDTO
 */
export interface ComputeAddtionalChargeDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof ComputeAddtionalChargeDTO
     */
    'items': Array<CartItemDTO>;
    /**
     * PickupPH supported order types, meal plan will be automatically changed to delivery (if not selected)
     * @type {string}
     * @memberof ComputeAddtionalChargeDTO
     */
    'order_type': ComputeAddtionalChargeDTOOrderTypeEnum;
}

export const ComputeAddtionalChargeDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    Digital: 'digital',
    Reservation: 'reservation'
} as const;

export type ComputeAddtionalChargeDTOOrderTypeEnum = typeof ComputeAddtionalChargeDTOOrderTypeEnum[keyof typeof ComputeAddtionalChargeDTOOrderTypeEnum];

/**
 * 
 * @export
 * @interface CreateReservationDTO
 */
export interface CreateReservationDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof CreateReservationDTO
     */
    'tables': Array<CartItemDTO>;
    /**
     * 
     * @type {CreateReservationDTOCustomer}
     * @memberof CreateReservationDTO
     */
    'customer'?: CreateReservationDTOCustomer;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'date': string;
    /**
     * Reservation time in HH:MM format
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'time': string;
    /**
     * Promo code
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'promo_code'?: string;
    /**
     * Optional for partner\'s that wishes to use their own checkout form/ui
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'payment_method'?: CreateReservationDTOPaymentMethodEnum;
    /**
     * Optional customer request
     * @type {string}
     * @memberof CreateReservationDTO
     */
    'remarks'?: string;
}

export const CreateReservationDTOPaymentMethodEnum = {
    Card: 'card',
    Gcash: 'gcash',
    GrabPay: 'grab_pay'
} as const;

export type CreateReservationDTOPaymentMethodEnum = typeof CreateReservationDTOPaymentMethodEnum[keyof typeof CreateReservationDTOPaymentMethodEnum];

/**
 * The customer\'s reservation information
 * @export
 * @interface CreateReservationDTOCustomer
 */
export interface CreateReservationDTOCustomer {
    /**
     * Customer first name
     * @type {string}
     * @memberof CreateReservationDTOCustomer
     */
    'first_name': string;
    /**
     * Customer last name
     * @type {string}
     * @memberof CreateReservationDTOCustomer
     */
    'last_name': string;
    /**
     * Valid personal or business email address
     * @type {string}
     * @memberof CreateReservationDTOCustomer
     */
    'email': string;
    /**
     * Valid mobile number
     * @type {string}
     * @memberof CreateReservationDTOCustomer
     */
    'mobile_number': string;
    /**
     * Customer ID that you want us to save for you, optional so you can pass guest users as well
     * @type {string}
     * @memberof CreateReservationDTOCustomer
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CurbsideArrivalResponse
 */
export interface CurbsideArrivalResponse {
    /**
     * api response for successfull customer arrival request
     * @type {boolean}
     * @memberof CurbsideArrivalResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CurbsidePickupDetail
 */
export interface CurbsidePickupDetail {
    /**
     * Indicates customer\'s arrival notice
     * @type {boolean}
     * @memberof CurbsidePickupDetail
     */
    'has_arrived': boolean;
    /**
     * Make of the customer\'s vehicle
     * @type {string}
     * @memberof CurbsidePickupDetail
     */
    'vehicle_make': string;
    /**
     * Color of the customer\'s vehicle
     * @type {string}
     * @memberof CurbsidePickupDetail
     */
    'vehicle_color': string;
    /**
     * Plate number of the customer\'s vehicle
     * @type {string}
     * @memberof CurbsidePickupDetail
     */
    'vehicle_plate': string;
    /**
     * Indicates merchant\'s confirmation of customer\'s arrival notice
     * @type {boolean}
     * @memberof CurbsidePickupDetail
     */
    'seen': boolean;
}
/**
 * 
 * @export
 * @interface CursbsidePickupDTO
 */
export interface CursbsidePickupDTO {
    /**
     * Vehicle make
     * @type {string}
     * @memberof CursbsidePickupDTO
     */
    'vehicle_make': string;
    /**
     * Vehicle color
     * @type {string}
     * @memberof CursbsidePickupDTO
     */
    'vehicle_color': string;
    /**
     * Vehicle plate number
     * @type {string}
     * @memberof CursbsidePickupDTO
     */
    'vehicle_plate_number': string;
}
/**
 * 
 * @export
 * @interface CustomerAddressDTO
 */
export interface CustomerAddressDTO {
    /**
     * Coordinate\'s longitude
     * @type {number}
     * @memberof CustomerAddressDTO
     */
    'lng': number;
    /**
     * Coordinate\'s latitude
     * @type {number}
     * @memberof CustomerAddressDTO
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface CustomerDetail
 */
export interface CustomerDetail {
    /**
     * Customer\'s first name
     * @type {string}
     * @memberof CustomerDetail
     */
    'first_name': string;
    /**
     * Customer\'s last name
     * @type {string}
     * @memberof CustomerDetail
     */
    'last_name': string;
    /**
     * Customer\'s email
     * @type {string}
     * @memberof CustomerDetail
     */
    'email': string;
    /**
     * Customer\'s phone number
     * @type {string}
     * @memberof CustomerDetail
     */
    'contact_number': string;
}
/**
 * 
 * @export
 * @interface CustomerDetailDTO
 */
export interface CustomerDetailDTO {
    /**
     * 
     * @type {CustomerDetailDTOAddress}
     * @memberof CustomerDetailDTO
     */
    'address'?: CustomerDetailDTOAddress;
    /**
     * The customer first name
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'first_name': string;
    /**
     * The customer last name
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'mobile_number': string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'email': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'id': string;
}
/**
 * The customer\'s address information
 * @export
 * @interface CustomerDetailDTOAddress
 */
export interface CustomerDetailDTOAddress {
    /**
     * Coordinate\'s longitude
     * @type {number}
     * @memberof CustomerDetailDTOAddress
     */
    'lng': number;
    /**
     * Coordinate\'s latitude
     * @type {number}
     * @memberof CustomerDetailDTOAddress
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface CustomerQuoteDTO
 */
export interface CustomerQuoteDTO {
    /**
     * 
     * @type {CustomerDetailDTOAddress}
     * @memberof CustomerQuoteDTO
     */
    'address': CustomerDetailDTOAddress;
    /**
     * address string use for delivery address
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'address_string': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof CustomerQuoteDTO
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeliveryOptionDTO
 */
export interface DeliveryOptionDTO {
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof DeliveryOptionDTO
     */
    'delivery_payment_method'?: DeliveryOptionDTODeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request
     * @type {string}
     * @memberof DeliveryOptionDTO
     */
    'delivery_vehicle'?: DeliveryOptionDTODeliveryVehicleEnum;
}

export const DeliveryOptionDTODeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type DeliveryOptionDTODeliveryPaymentMethodEnum = typeof DeliveryOptionDTODeliveryPaymentMethodEnum[keyof typeof DeliveryOptionDTODeliveryPaymentMethodEnum];
export const DeliveryOptionDTODeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type DeliveryOptionDTODeliveryVehicleEnum = typeof DeliveryOptionDTODeliveryVehicleEnum[keyof typeof DeliveryOptionDTODeliveryVehicleEnum];

/**
 * 
 * @export
 * @interface DeliveryQuotationEntity
 */
export interface DeliveryQuotationEntity {
    /**
     * Quoted Delivery Fee from respective partner
     * @type {number}
     * @memberof DeliveryQuotationEntity
     */
    'delivery_fee': number;
    /**
     * Priority fee on top of delivery fee, ONLY supported by lalamove
     * @type {number}
     * @memberof DeliveryQuotationEntity
     */
    'priority_fee': number;
    /**
     * Delivery Partner quotation source
     * @type {string}
     * @memberof DeliveryQuotationEntity
     */
    'partner': string;
    /**
     * Indicator for the success quotation
     * @type {boolean}
     * @memberof DeliveryQuotationEntity
     */
    'is_success': boolean;
    /**
     * Indicator for the success quotation
     * @type {Array<string>}
     * @memberof DeliveryQuotationEntity
     */
    'message'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeliveryQuotationResultEntity
 */
export interface DeliveryQuotationResultEntity {
    /**
     * 
     * @type {DeliveryQuotationResultEntitySelected}
     * @memberof DeliveryQuotationResultEntity
     */
    'selected': DeliveryQuotationResultEntitySelected;
    /**
     * List of active delivery partners from quotation , for quotation reference on multihailing stores
     * @type {Array<DeliveryQuotationEntity>}
     * @memberof DeliveryQuotationResultEntity
     */
    'delivery_partner_quotations'?: Array<DeliveryQuotationEntity>;
}
/**
 * The selected delivery quotation and will be used in the final computation of total amopunt to be paid
 * @export
 * @interface DeliveryQuotationResultEntitySelected
 */
export interface DeliveryQuotationResultEntitySelected {
    /**
     * Quoted Delivery Fee from respective partner
     * @type {number}
     * @memberof DeliveryQuotationResultEntitySelected
     */
    'delivery_fee': number;
    /**
     * Priority fee on top of delivery fee, ONLY supported by lalamove
     * @type {number}
     * @memberof DeliveryQuotationResultEntitySelected
     */
    'priority_fee': number;
    /**
     * Delivery Partner quotation source
     * @type {string}
     * @memberof DeliveryQuotationResultEntitySelected
     */
    'partner': string;
    /**
     * Indicator for the success quotation
     * @type {boolean}
     * @memberof DeliveryQuotationResultEntitySelected
     */
    'is_success': boolean;
    /**
     * Indicator for the success quotation
     * @type {Array<string>}
     * @memberof DeliveryQuotationResultEntitySelected
     */
    'message'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventAvailabilityClass
 */
export interface EventAvailabilityClass {
    /**
     * List of tickets and its availability
     * @type {Array<EventTicketAvailabilityClass>}
     * @memberof EventAvailabilityClass
     */
    'tickets': Array<EventTicketAvailabilityClass>;
}
/**
 * 
 * @export
 * @interface EventClass
 */
export interface EventClass {
    /**
     * Event id
     * @type {string}
     * @memberof EventClass
     */
    'id': string;
    /**
     * Event promotion image url
     * @type {string}
     * @memberof EventClass
     */
    'image': string;
    /**
     * 
     * @type {StoreEventClassTickets}
     * @memberof EventClass
     */
    'tickets': StoreEventClassTickets;
    /**
     * 
     * @type {StoreEventClassTimeSlots}
     * @memberof EventClass
     */
    'time_slots': StoreEventClassTimeSlots;
    /**
     * 
     * @type {EventClassStore}
     * @memberof EventClass
     */
    'store': EventClassStore;
    /**
     * Event name
     * @type {string}
     * @memberof EventClass
     */
    'name': string;
    /**
     * Indicates event exclusivity
     * @type {string}
     * @memberof EventClass
     */
    'status': string;
    /**
     * Event description
     * @type {string}
     * @memberof EventClass
     */
    'description': string;
    /**
     * Event cancellation policy
     * @type {string}
     * @memberof EventClass
     */
    'cancellation_policy': string;
    /**
     * Event dress code
     * @type {string}
     * @memberof EventClass
     */
    'dress_code': string;
    /**
     * Distance from location_point to Store Distance in meters
     * @type {number}
     * @memberof EventClass
     */
    'distance': number;
    /**
     * Event human readable address
     * @type {string}
     * @memberof EventClass
     */
    'location_address': string;
    /**
     * Event geo location - lng,lat
     * @type {string}
     * @memberof EventClass
     */
    'location': string;
    /**
     * Event start date
     * @type {string}
     * @memberof EventClass
     */
    'start_date': string;
    /**
     * Event end date
     * @type {string}
     * @memberof EventClass
     */
    'end_date': string;
    /**
     * Days of the week when the event is available 0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday
     * @type {Array<number>}
     * @memberof EventClass
     */
    'available_days': Array<number>;
    /**
     * Cutoff time for ordering the event in minutes 0 = no cutoff
     * @type {number}
     * @memberof EventClass
     */
    'ordering_cutoff': number;
}
/**
 * Store information
 * @export
 * @interface EventClassStore
 */
export interface EventClassStore {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof EventClassStore
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof EventClassStore
     */
    'banner': string;
    /**
     * Store display name
     * @type {string}
     * @memberof EventClassStore
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof EventClassStore
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof EventClassStore
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof EventClassStore
     */
    'partner_banner': string;
    /**
     * Store description
     * @type {string}
     * @memberof EventClassStore
     */
    'store_description': string;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof EventClassStore
     */
    'contact_number': string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof EventClassStore
     */
    'store_tags'?: Array<string>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof EventClassStore
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof EventClassStore
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof EventClassStore
     */
    'geocode_location'?: string;
}
/**
 * 
 * @export
 * @interface EventDetail
 */
export interface EventDetail {
    /**
     * Event id
     * @type {string}
     * @memberof EventDetail
     */
    'id': string;
    /**
     * Event promotion image url
     * @type {string}
     * @memberof EventDetail
     */
    'image': string;
    /**
     * Event name
     * @type {string}
     * @memberof EventDetail
     */
    'name': string;
    /**
     * Event start date
     * @type {string}
     * @memberof EventDetail
     */
    'start_date': string;
    /**
     * Event end date
     * @type {string}
     * @memberof EventDetail
     */
    'end_date': string;
    /**
     * Event human readable address
     * @type {string}
     * @memberof EventDetail
     */
    'location_address': string;
    /**
     * Event description
     * @type {string}
     * @memberof EventDetail
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface EventEntity
 */
export interface EventEntity {
    /**
     * Indicates if there is a page after the current one
     * @type {boolean}
     * @memberof EventEntity
     */
    'has_next_page': boolean;
    /**
     * Indicates if there is a page before the current one
     * @type {boolean}
     * @memberof EventEntity
     */
    'has_prev_page': boolean;
    /**
     * Total number of pages according to limit and result
     * @type {number}
     * @memberof EventEntity
     */
    'total_pages': number;
    /**
     * Total number of records found against the query
     * @type {number}
     * @memberof EventEntity
     */
    'total_records': number;
    /**
     * 
     * @type {Array<EventClass>}
     * @memberof EventEntity
     */
    'result': Array<EventClass>;
    /**
     * Indicates current page
     * @type {number}
     * @memberof EventEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface EventItem
 */
export interface EventItem {
    /**
     * Event item id, use for buying seats
     * @type {string}
     * @memberof EventItem
     */
    'id': string;
    /**
     * Event item image url
     * @type {string}
     * @memberof EventItem
     */
    'image': string;
    /**
     * Event item code
     * @type {string}
     * @memberof EventItem
     */
    'code': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof EventItem
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Event ticket name
     * @type {string}
     * @memberof EventItem
     */
    'name': string;
    /**
     * Event ticket description
     * @type {string}
     * @memberof EventItem
     */
    'description': string;
    /**
     * Event item price
     * @type {number}
     * @memberof EventItem
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface EventStoreDetailsClass
 */
export interface EventStoreDetailsClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'banner': string;
    /**
     * Store display name
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'partner_banner': string;
    /**
     * Store description
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'store_description': string;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'contact_number': string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof EventStoreDetailsClass
     */
    'store_tags'?: Array<string>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof EventStoreDetailsClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof EventStoreDetailsClass
     */
    'geocode_location'?: string;
}
/**
 * 
 * @export
 * @interface EventTicketAvailabilityClass
 */
export interface EventTicketAvailabilityClass {
    /**
     * Indicates ticket availability
     * @type {boolean}
     * @memberof EventTicketAvailabilityClass
     */
    'available': boolean;
    /**
     * Ticket id
     * @type {string}
     * @memberof EventTicketAvailabilityClass
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface EventTicketClass
 */
export interface EventTicketClass {
    /**
     * 
     * @type {EventTicketClassItem}
     * @memberof EventTicketClass
     */
    'item': EventTicketClassItem;
    /**
     * Event seating capacity
     * @type {number}
     * @memberof EventTicketClass
     */
    'capacity': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventTicketClass
     */
    'time_slots': Array<string>;
}
/**
 * Event ticket data
 * @export
 * @interface EventTicketClassItem
 */
export interface EventTicketClassItem {
    /**
     * Event item id, use for buying seats
     * @type {string}
     * @memberof EventTicketClassItem
     */
    'id': string;
    /**
     * Event item image url
     * @type {string}
     * @memberof EventTicketClassItem
     */
    'image': string;
    /**
     * Event item code
     * @type {string}
     * @memberof EventTicketClassItem
     */
    'code': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof EventTicketClassItem
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Event ticket name
     * @type {string}
     * @memberof EventTicketClassItem
     */
    'name': string;
    /**
     * Event ticket description
     * @type {string}
     * @memberof EventTicketClassItem
     */
    'description': string;
    /**
     * Event item price
     * @type {number}
     * @memberof EventTicketClassItem
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface EventTimeSlots
 */
export interface EventTimeSlots {
    /**
     * Time slot id
     * @type {string}
     * @memberof EventTimeSlots
     */
    'id': string;
    /**
     * Indicates possible event ticket time inclusion scope
     * @type {string}
     * @memberof EventTimeSlots
     */
    'start_time': string;
    /**
     * Indicates possible event ticket time inclusion scope
     * @type {string}
     * @memberof EventTimeSlots
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface ExtraGroupClass
 */
export interface ExtraGroupClass {
    /**
     * Indicates if extras within a group is REQUIRED to be added on cart with the item
     * @type {boolean}
     * @memberof ExtraGroupClass
     */
    'is_required': boolean;
    /**
     * List of extras within a group
     * @type {Array<GroupSelectionClass>}
     * @memberof ExtraGroupClass
     */
    'extras'?: Array<GroupSelectionClass>;
    /**
     * The name of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'name': string;
    /**
     * The description of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'description': string;
    /**
     * Minimum number of extras within a group that NEEDS to be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'minimum_number': number;
    /**
     * Maximum number of extras within a group that can be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'maximum_number': number;
    /**
     * Nominated position of the extra group in a list
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface GroupSelectionClass
 */
export interface GroupSelectionClass {
    /**
     * The unique bson identifier of the extra, to be used on the create cart endpoint
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'id': string;
    /**
     * Nominated position of the extra in a list
     * @type {number}
     * @memberof GroupSelectionClass
     */
    'position': number;
    /**
     * Random unique identifier for extras
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'extra_code': string;
    /**
     * Pertains to the regular price of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'price': string;
    /**
     * The name of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'name': string;
    /**
     * Extra item is available for order
     * @type {boolean}
     * @memberof GroupSelectionClass
     */
    'available'?: boolean;
    /**
     * Extra item description
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ItemClass
 */
export interface ItemClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemClass
     */
    'id': string;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof ItemClass
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_meal_plan'?: boolean;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof ItemClass
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof ItemClass
     */
    'item_code': string;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof ItemClass
     */
    'item_limit_per_day'?: number;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'tags': Array<string>;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemClass
     */
    'visible'?: boolean;
    /**
     * Indicates item type
     * @type {string}
     * @memberof ItemClass
     */
    'type': ItemClassTypeEnum;
}

export const ItemClassTypeEnum = {
    Promo: 'promo',
    Default: 'default',
    Event: 'event',
    Reservation: 'reservation'
} as const;

export type ItemClassTypeEnum = typeof ItemClassTypeEnum[keyof typeof ItemClassTypeEnum];

/**
 * 
 * @export
 * @interface ItemInventoryEntity
 */
export interface ItemInventoryEntity {
    /**
     * Number of available item in inventory, -1 means unlimited item stock
     * @type {number}
     * @memberof ItemInventoryEntity
     */
    'item_stock': number;
    /**
     * Number of available item in inventory per category, -1 means unlimited category stock
     * @type {number}
     * @memberof ItemInventoryEntity
     */
    'category_stock': number;
    /**
     * Available stock that CAN be added to cart, -1 means unlimited stock for both item and category stock Use this as general rule of thumb in displaying item stock availability in UI This SHOULD equal to item_stock if category_stock is higher, and vice versa E.g. item_stock = 3 category_stock = 5 available = 3
     * @type {number}
     * @memberof ItemInventoryEntity
     */
    'available': number;
}
/**
 * 
 * @export
 * @interface ItemPartialClass
 */
export interface ItemPartialClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemPartialClass
     */
    'id': string;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemPartialClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemPartialClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemPartialClass
     */
    'tags': Array<string>;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemPartialClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'visible'?: boolean;
    /**
     * Indicates item type
     * @type {string}
     * @memberof ItemPartialClass
     */
    'type': ItemPartialClassTypeEnum;
}

export const ItemPartialClassTypeEnum = {
    Promo: 'promo',
    Default: 'default',
    Event: 'event',
    Reservation: 'reservation'
} as const;

export type ItemPartialClassTypeEnum = typeof ItemPartialClassTypeEnum[keyof typeof ItemPartialClassTypeEnum];

/**
 * 
 * @export
 * @interface ItemTimeSlotClass
 */
export interface ItemTimeSlotClass {
    /**
     * Time-slot indicator
     * @type {string}
     * @memberof ItemTimeSlotClass
     */
    'time_slot': string;
    /**
     * Indicates the limit of purchases an item could have in a time slot
     * @type {number}
     * @memberof ItemTimeSlotClass
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ItemsEntity
 */
export interface ItemsEntity {
    /**
     * Indicates if there is a page after the current one
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_next_page': boolean;
    /**
     * Indicates if there is a page before the current one
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_prev_page': boolean;
    /**
     * Total number of pages according to limit and result
     * @type {number}
     * @memberof ItemsEntity
     */
    'total_pages': number;
    /**
     * Total number of records found against the query
     * @type {number}
     * @memberof ItemsEntity
     */
    'total_records': number;
    /**
     * Search results
     * @type {Array<ItemPartialClass>}
     * @memberof ItemsEntity
     */
    'result': Array<ItemPartialClass>;
    /**
     * Indicates current page
     * @type {number}
     * @memberof ItemsEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface LocationPointDTO
 */
export interface LocationPointDTO {
    /**
     * Maximum store delivery distance in kilometers
     * @type {number}
     * @memberof LocationPointDTO
     */
    'max_radius': number;
    /**
     * Coordinate\'s longitude
     * @type {number}
     * @memberof LocationPointDTO
     */
    'lng': number;
    /**
     * Coordinate\'s latitude
     * @type {number}
     * @memberof LocationPointDTO
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface MenuClass
 */
export interface MenuClass {
    /**
     * 
     * @type {MenuClassItem}
     * @memberof MenuClass
     */
    'item': MenuClassItem;
    /**
     * Item limit per day 0 = category is not limited
     * @type {number}
     * @memberof MenuClass
     */
    'item_limit_per_day': number;
    /**
     * To check if the item is available
     * @type {boolean}
     * @memberof MenuClass
     */
    'available': boolean;
    /**
     * True if the item should be visible to the customer , item can be available but not be visible
     * @type {boolean}
     * @memberof MenuClass
     */
    'visible': boolean;
    /**
     * Position of the item in the store menu
     * @type {number}
     * @memberof MenuClass
     */
    'order_position': number;
    /**
     * Item category name
     * @type {string}
     * @memberof MenuClass
     */
    'category': string;
    /**
     * Item limit per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClass
     */
    'item_limit_per_time_slot': Array<ItemTimeSlotClass>;
    /**
     * Indicates available stock at the time of pulling the store data
     * @type {number}
     * @memberof MenuClass
     */
    'stock': number;
}
/**
 * Item id that will be used for cart building on /cart route
 * @export
 * @interface MenuClassItem
 */
export interface MenuClassItem {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof MenuClassItem
     */
    'id': string;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof MenuClassItem
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_meal_plan'?: boolean;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof MenuClassItem
     */
    'image_url': string;
    /**
     * The name of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'description': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof MenuClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof MenuClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof MenuClassItem
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'tags': Array<string>;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'extras'?: boolean;
    /**
     * Indicates item type
     * @type {string}
     * @memberof MenuClassItem
     */
    'type': MenuClassItemTypeEnum;
    /**
     * Random unique item code
     * @type {string}
     * @memberof MenuClassItem
     */
    'item_code': string;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'off_dates'?: Array<string>;
}

export const MenuClassItemTypeEnum = {
    Promo: 'promo',
    Default: 'default',
    Event: 'event',
    Reservation: 'reservation'
} as const;

export type MenuClassItemTypeEnum = typeof MenuClassItemTypeEnum[keyof typeof MenuClassItemTypeEnum];

/**
 * 
 * @export
 * @interface MenuItemClass
 */
export interface MenuItemClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof MenuItemClass
     */
    'id': string;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof MenuItemClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof MenuItemClass
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof MenuItemClass
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof MenuItemClass
     */
    'is_meal_plan'?: boolean;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof MenuItemClass
     */
    'image_url': string;
    /**
     * The name of the item
     * @type {string}
     * @memberof MenuItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof MenuItemClass
     */
    'description': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof MenuItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof MenuItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof MenuItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof MenuItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof MenuItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof MenuItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof MenuItemClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof MenuItemClass
     */
    'tags': Array<string>;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof MenuItemClass
     */
    'extras'?: boolean;
    /**
     * Indicates item type
     * @type {string}
     * @memberof MenuItemClass
     */
    'type': MenuItemClassTypeEnum;
    /**
     * Random unique item code
     * @type {string}
     * @memberof MenuItemClass
     */
    'item_code': string;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof MenuItemClass
     */
    'off_dates'?: Array<string>;
}

export const MenuItemClassTypeEnum = {
    Promo: 'promo',
    Default: 'default',
    Event: 'event',
    Reservation: 'reservation'
} as const;

export type MenuItemClassTypeEnum = typeof MenuItemClassTypeEnum[keyof typeof MenuItemClassTypeEnum];

/**
 * 
 * @export
 * @interface OrderAdditionalCharge
 */
export interface OrderAdditionalCharge {
    /**
     * Computed additional charge amount
     * @type {number}
     * @memberof OrderAdditionalCharge
     */
    'amount': number;
    /**
     * Additional charge classification
     * @type {string}
     * @memberof OrderAdditionalCharge
     */
    'name': string;
    /**
     * Additional charge type values can be amount_charge , percent_charge
     * @type {string}
     * @memberof OrderAdditionalCharge
     */
    'type': OrderAdditionalChargeTypeEnum;
    /**
     * This number can be by percent or amount determined by type field to compute the additional charge required by the store , example (total_amount + 100)
     * @type {number}
     * @memberof OrderAdditionalCharge
     */
    'factor': number;
}

export const OrderAdditionalChargeTypeEnum = {
    AmountCharge: 'amount_charge',
    PercentCharge: 'percent_charge'
} as const;

export type OrderAdditionalChargeTypeEnum = typeof OrderAdditionalChargeTypeEnum[keyof typeof OrderAdditionalChargeTypeEnum];

/**
 * 
 * @export
 * @interface OrderDetailsClass
 */
export interface OrderDetailsClass {
    /**
     * Item order quantity
     * @type {number}
     * @memberof OrderDetailsClass
     */
    'quantity': number;
    /**
     * 
     * @type {OrderDetailsClassItem}
     * @memberof OrderDetailsClass
     */
    'item'?: OrderDetailsClassItem;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderDetailsClass
     */
    'id': string;
    /**
     * 
     * @type {Array<OrderExtraClass>}
     * @memberof OrderDetailsClass
     */
    'extras': Array<OrderExtraClass>;
}
/**
 * Item information
 * @export
 * @interface OrderDetailsClassItem
 */
export interface OrderDetailsClassItem {
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'image_url': string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof OrderDetailsClassItem
     */
    'regular_price': string;
}
/**
 * 
 * @export
 * @interface OrderEntity
 */
export interface OrderEntity {
    /**
     * Indicates if there is a page after the current one
     * @type {boolean}
     * @memberof OrderEntity
     */
    'has_next_page': boolean;
    /**
     * Indicates if there is a page before the current one
     * @type {boolean}
     * @memberof OrderEntity
     */
    'has_prev_page': boolean;
    /**
     * Total number of pages according to limit and result
     * @type {number}
     * @memberof OrderEntity
     */
    'total_pages': number;
    /**
     * Total number of records found against the query
     * @type {number}
     * @memberof OrderEntity
     */
    'total_records': number;
    /**
     * 
     * @type {Array<OrderPartialClass>}
     * @memberof OrderEntity
     */
    'result': Array<OrderPartialClass>;
    /**
     * Indicates current page
     * @type {number}
     * @memberof OrderEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface OrderExtraClass
 */
export interface OrderExtraClass {
    /**
     * Unique extra code
     * @type {string}
     * @memberof OrderExtraClass
     */
    'code': string;
    /**
     * Extra ID
     * @type {string}
     * @memberof OrderExtraClass
     */
    'id': string;
    /**
     * Name of the extra
     * @type {string}
     * @memberof OrderExtraClass
     */
    'name': string;
    /**
     * Indicates the regular price of the extra
     * @type {string}
     * @memberof OrderExtraClass
     */
    'price'?: string;
}
/**
 * 
 * @export
 * @interface OrderItemClass
 */
export interface OrderItemClass {
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof OrderItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof OrderItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof OrderItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof OrderItemClass
     */
    'image_url': string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof OrderItemClass
     */
    'price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof OrderItemClass
     */
    'regular_price': string;
}
/**
 * 
 * @export
 * @interface OrderPartialClass
 */
export interface OrderPartialClass {
    /**
     * Order ID that will be used to search
     * @type {string}
     * @memberof OrderPartialClass
     */
    'id': string;
    /**
     * 
     * @type {OrderPartialClassCustomer}
     * @memberof OrderPartialClass
     */
    'customer': OrderPartialClassCustomer;
    /**
     * Total order amount charged to the customer
     * @type {number}
     * @memberof OrderPartialClass
     */
    'total_amount'?: number;
    /**
     * Total item amount without delivery fee and discounts applied
     * @type {number}
     * @memberof OrderPartialClass
     */
    'items_total_amount': number;
    /**
     * Delivery fee charged if order type is delivery
     * @type {string}
     * @memberof OrderPartialClass
     */
    'charged_delivery_fee': string;
    /**
     * Indicates delivery fee was paid via cash
     * @type {boolean}
     * @memberof OrderPartialClass
     */
    'delivery_paid_by_cash': boolean;
    /**
     * Promotional discount applied on amount paid
     * @type {number}
     * @memberof OrderPartialClass
     */
    'promo_discount': number;
    /**
     * Indicates where the promotional discount has been applied
     * @type {object}
     * @memberof OrderPartialClass
     */
    'promo_base': OrderPartialClassPromoBaseEnum;
    /**
     * Customer notes
     * @type {string}
     * @memberof OrderPartialClass
     */
    'customer_notes': string;
    /**
     * Indicates if the order is part of a meal plan
     * @type {boolean}
     * @memberof OrderPartialClass
     */
    'meal_plan': boolean;
    /**
     * Indicates discount applied to a meal plan
     * @type {string}
     * @memberof OrderPartialClass
     */
    'meal_plan_discount'?: string;
    /**
     * Indicates the applied delivery discount at the time of ordering
     * @type {string}
     * @memberof OrderPartialClass
     */
    'meal_plan_delivery_discount'?: string;
    /**
     * Indicates total delivery fee quoted for a meal plan
     * @type {string}
     * @memberof OrderPartialClass
     */
    'meal_plan_quoted_delivery_fee'?: string;
    /**
     * Indicates order placement as part of a meal plan i.e. placement/total
     * @type {string}
     * @memberof OrderPartialClass
     */
    'meal_plan_index'?: string;
    /**
     * Order type
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_type': OrderPartialClassOrderTypeEnum;
    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_date': string;
    /**
     * Order time filter in HH:MM format
     * @type {string}
     * @memberof OrderPartialClass
     */
    'order_time': string;
    /**
     * Order delivery address, empty if order type is pickup or curbside pickup
     * @type {string}
     * @memberof OrderPartialClass
     */
    'delivery_address': string;
    /**
     * Order delivery status
     * @type {string}
     * @memberof OrderPartialClass
     */
    'delivery_status'?: OrderPartialClassDeliveryStatusEnum;
    /**
     * Order delivery tracking link
     * @type {string}
     * @memberof OrderPartialClass
     */
    'delivery_tracking_link'?: string;
    /**
     * Order status, expired means the cart was abandoned
     * @type {string}
     * @memberof OrderPartialClass
     */
    'status'?: OrderPartialClassStatusEnum;
    /**
     * Order Details
     * @type {Array<OrderDetailsClass>}
     * @memberof OrderPartialClass
     */
    'order_details': Array<OrderDetailsClass>;
    /**
     * 
     * @type {OrderPartialClassStoreDetails}
     * @memberof OrderPartialClass
     */
    'store_details': OrderPartialClassStoreDetails;
    /**
     * Status update timestamps
     * @type {object}
     * @memberof OrderPartialClass
     */
    'change_timestamp': object;
    /**
     * Transaction number, this serves as pickup\'s order number
     * @type {string}
     * @memberof OrderPartialClass
     */
    'transaction_number': string;
    /**
     * Payment method used
     * @type {string}
     * @memberof OrderPartialClass
     */
    'payment_method'?: string;
    /**
     * Refunded amount, can be partial or full
     * @type {number}
     * @memberof OrderPartialClass
     */
    'refunded_amount': number;
    /**
     * 
     * @type {OrderPartialClassPickupDetails}
     * @memberof OrderPartialClass
     */
    'pickup_details': OrderPartialClassPickupDetails;
    /**
     * 
     * @type {OrderPartialClassCurbsidePickupDetails}
     * @memberof OrderPartialClass
     */
    'curbside_pickup_details'?: OrderPartialClassCurbsidePickupDetails;
    /**
     * 
     * @type {OrderPartialClassEventDetails}
     * @memberof OrderPartialClass
     */
    'event_details'?: OrderPartialClassEventDetails;
    /**
     * Tracking page for this particular order
     * @type {string}
     * @memberof OrderPartialClass
     */
    'tracking_page': string;
    /**
     * 
     * @type {OrderPartialClassPromo}
     * @memberof OrderPartialClass
     */
    'promo': OrderPartialClassPromo;
    /**
     * Store notes
     * @type {string}
     * @memberof OrderPartialClass
     */
    'store_notes': string;
    /**
     * Additional Charges included on the order
     * @type {Array<OrderAdditionalCharge>}
     * @memberof OrderPartialClass
     */
    'additional_charges': Array<OrderAdditionalCharge>;
}

export const OrderPartialClassPromoBaseEnum = {
    Cart: 'cart',
    Delivery: 'delivery'
} as const;

export type OrderPartialClassPromoBaseEnum = typeof OrderPartialClassPromoBaseEnum[keyof typeof OrderPartialClassPromoBaseEnum];
export const OrderPartialClassOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    Digital: 'digital',
    Reservation: 'reservation'
} as const;

export type OrderPartialClassOrderTypeEnum = typeof OrderPartialClassOrderTypeEnum[keyof typeof OrderPartialClassOrderTypeEnum];
export const OrderPartialClassDeliveryStatusEnum = {
    Assigning: 'ASSIGNING',
    OnGoing: 'ON_GOING',
    PickedUp: 'PICKED_UP',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type OrderPartialClassDeliveryStatusEnum = typeof OrderPartialClassDeliveryStatusEnum[keyof typeof OrderPartialClassDeliveryStatusEnum];
export const OrderPartialClassStatusEnum = {
    New: 'new',
    OutForDelivery: 'out_for_delivery',
    Accepted: 'accepted',
    Ready: 'ready',
    Cancelled: 'cancelled',
    Completed: 'completed',
    Refunded: 'refunded',
    Expired: 'expired',
    PaymentFailed: 'payment_failed',
    PaymentPending: 'payment_pending'
} as const;

export type OrderPartialClassStatusEnum = typeof OrderPartialClassStatusEnum[keyof typeof OrderPartialClassStatusEnum];

/**
 * Curbside pickup information
 * @export
 * @interface OrderPartialClassCurbsidePickupDetails
 */
export interface OrderPartialClassCurbsidePickupDetails {
    /**
     * Indicates customer\'s arrival notice
     * @type {boolean}
     * @memberof OrderPartialClassCurbsidePickupDetails
     */
    'has_arrived': boolean;
    /**
     * Make of the customer\'s vehicle
     * @type {string}
     * @memberof OrderPartialClassCurbsidePickupDetails
     */
    'vehicle_make': string;
    /**
     * Color of the customer\'s vehicle
     * @type {string}
     * @memberof OrderPartialClassCurbsidePickupDetails
     */
    'vehicle_color': string;
    /**
     * Plate number of the customer\'s vehicle
     * @type {string}
     * @memberof OrderPartialClassCurbsidePickupDetails
     */
    'vehicle_plate': string;
    /**
     * Indicates merchant\'s confirmation of customer\'s arrival notice
     * @type {boolean}
     * @memberof OrderPartialClassCurbsidePickupDetails
     */
    'seen': boolean;
}
/**
 * Guest customer information
 * @export
 * @interface OrderPartialClassCustomer
 */
export interface OrderPartialClassCustomer {
    /**
     * Customer\'s first name
     * @type {string}
     * @memberof OrderPartialClassCustomer
     */
    'first_name': string;
    /**
     * Customer\'s last name
     * @type {string}
     * @memberof OrderPartialClassCustomer
     */
    'last_name': string;
    /**
     * Customer\'s email
     * @type {string}
     * @memberof OrderPartialClassCustomer
     */
    'email': string;
    /**
     * Customer\'s phone number
     * @type {string}
     * @memberof OrderPartialClassCustomer
     */
    'contact_number': string;
}
/**
 * Event details information
 * @export
 * @interface OrderPartialClassEventDetails
 */
export interface OrderPartialClassEventDetails {
    /**
     * Event id
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'id': string;
    /**
     * Event promotion image url
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'image': string;
    /**
     * Event name
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'name': string;
    /**
     * Event start date
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'start_date': string;
    /**
     * Event end date
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'end_date': string;
    /**
     * Event human readable address
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'location_address': string;
    /**
     * Event description
     * @type {string}
     * @memberof OrderPartialClassEventDetails
     */
    'description': string;
}
/**
 * Third party pickup information
 * @export
 * @interface OrderPartialClassPickupDetails
 */
export interface OrderPartialClassPickupDetails {
    /**
     * Customer\'s first name
     * @type {string}
     * @memberof OrderPartialClassPickupDetails
     */
    'first_name': string;
    /**
     * Customer\'s last name
     * @type {string}
     * @memberof OrderPartialClassPickupDetails
     */
    'last_name': string;
    /**
     * Customer\'s phone number
     * @type {string}
     * @memberof OrderPartialClassPickupDetails
     */
    'contact_number': string;
}
/**
 * Applied promo information
 * @export
 * @interface OrderPartialClassPromo
 */
export interface OrderPartialClassPromo {
    /**
     * Identifies order types this promo belongs to
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'applies_to': OrderPartialClassPromoAppliesToEnum;
    /**
     * Promo code
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'code': string;
    /**
     * Type of this promo
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'type': OrderPartialClassPromoTypeEnum;
    /**
     * Promo discount as amount deductable
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'amount_off': number;
    /**
     * Promo discount as percentage
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'percentage_off': number;
    /**
     * Promo discount for delivery fee
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'subsidized_delivery_amount': number;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof OrderPartialClassPromo
     */
    'minimum_purchase': number;
    /**
     * Promo description
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'free_item_description'?: string;
    /**
     * Promo start date
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'start_date': string;
    /**
     * Promo end date, null means promo does not expire via date
     * @type {string}
     * @memberof OrderPartialClassPromo
     */
    'end_date': string;
}

export const OrderPartialClassPromoAppliesToEnum = {
    Pickup: 'pickup',
    Delivery: 'delivery',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    DineIn: 'dine_in',
    MealPlan: 'meal_plan',
    Digital: 'digital'
} as const;

export type OrderPartialClassPromoAppliesToEnum = typeof OrderPartialClassPromoAppliesToEnum[keyof typeof OrderPartialClassPromoAppliesToEnum];
export const OrderPartialClassPromoTypeEnum = {
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery',
    FreeItem: 'free_item'
} as const;

export type OrderPartialClassPromoTypeEnum = typeof OrderPartialClassPromoTypeEnum[keyof typeof OrderPartialClassPromoTypeEnum];

/**
 * Store Details
 * @export
 * @interface OrderPartialClassStoreDetails
 */
export interface OrderPartialClassStoreDetails {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'banner': string;
    /**
     * Store display name
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof OrderPartialClassStoreDetails
     */
    'partner_banner': string;
}
/**
 * 
 * @export
 * @interface PromoDTO
 */
export interface PromoDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof PromoDTO
     */
    'items': Array<CartItemDTO>;
    /**
     * Indicates delivery payment will be paid by cash
     * @type {boolean}
     * @memberof PromoDTO
     */
    'is_cod': boolean;
    /**
     * Promo code
     * @type {string}
     * @memberof PromoDTO
     */
    'promo_code': string;
    /**
     * Store ID where the promo needs to be validated against
     * @type {string}
     * @memberof PromoDTO
     */
    'store_id': string;
    /**
     * Intended order type for this promo
     * @type {string}
     * @memberof PromoDTO
     */
    'order_type': PromoDTOOrderTypeEnum;
}

export const PromoDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    Digital: 'digital',
    Reservation: 'reservation'
} as const;

export type PromoDTOOrderTypeEnum = typeof PromoDTOOrderTypeEnum[keyof typeof PromoDTOOrderTypeEnum];

/**
 * 
 * @export
 * @interface PromoDiscountDetails
 */
export interface PromoDiscountDetails {
    /**
     * Amount to be paid before promo is applied, used as base of calculation
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'original': number;
    /**
     * Total amount after calculated promo is applied
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'applied': number;
    /**
     * Calculated promo value deducted from original price
     * @type {number}
     * @memberof PromoDiscountDetails
     */
    'total': number;
    /**
     * Base promo value, if promo type is amount_off this is Php 20.00 if type is percentage_off this is 20%
     * @type {string}
     * @memberof PromoDiscountDetails
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface PromoEntity
 */
export interface PromoEntity {
    /**
     * Identifies order types this promo belongs to
     * @type {string}
     * @memberof PromoEntity
     */
    'applies_to': PromoEntityAppliesToEnum;
    /**
     * Promo code
     * @type {string}
     * @memberof PromoEntity
     */
    'code': string;
    /**
     * Type of this promo
     * @type {string}
     * @memberof PromoEntity
     */
    'type': PromoEntityTypeEnum;
    /**
     * Promo discount as amount deductable
     * @type {number}
     * @memberof PromoEntity
     */
    'amount_off': number;
    /**
     * Promo discount as percentage
     * @type {number}
     * @memberof PromoEntity
     */
    'percentage_off': number;
    /**
     * Promo discount for delivery fee
     * @type {number}
     * @memberof PromoEntity
     */
    'subsidized_delivery_amount': number;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof PromoEntity
     */
    'minimum_purchase': number;
    /**
     * Promo description
     * @type {string}
     * @memberof PromoEntity
     */
    'free_item_description'?: string;
    /**
     * Promo start date
     * @type {string}
     * @memberof PromoEntity
     */
    'start_date': string;
    /**
     * Promo end date, null means promo does not expire via date
     * @type {string}
     * @memberof PromoEntity
     */
    'end_date': string;
}

export const PromoEntityAppliesToEnum = {
    Pickup: 'pickup',
    Delivery: 'delivery',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    DineIn: 'dine_in',
    MealPlan: 'meal_plan',
    Digital: 'digital'
} as const;

export type PromoEntityAppliesToEnum = typeof PromoEntityAppliesToEnum[keyof typeof PromoEntityAppliesToEnum];
export const PromoEntityTypeEnum = {
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery',
    FreeItem: 'free_item'
} as const;

export type PromoEntityTypeEnum = typeof PromoEntityTypeEnum[keyof typeof PromoEntityTypeEnum];

/**
 * 
 * @export
 * @interface PromoListResponse
 */
export interface PromoListResponse {
    /**
     * List of promos
     * @type {Array<PromoEntity>}
     * @memberof PromoListResponse
     */
    'promos': Array<PromoEntity>;
}
/**
 * 
 * @export
 * @interface QuotationRequestDTO
 */
export interface QuotationRequestDTO {
    /**
     * 
     * @type {QuotationRequestDTOCustomer}
     * @memberof QuotationRequestDTO
     */
    'customer': QuotationRequestDTOCustomer;
    /**
     * The 24 character hexadecimal string id of the store (origin)
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'id': string;
    /**
     * Optional value for Delivery payment method type , [cash = customer pay to rider , non_cash = added to checkout] not applicable for Lalamove
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'delivery_payment_method': QuotationRequestDTODeliveryPaymentMethodEnum;
    /**
     * Delivery Vehicle Type for the request , null will default to motorcycle
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'delivery_vehicle': QuotationRequestDTODeliveryVehicleEnum;
    /**
     * Delivery schedule time in HH:MM format , null will default to asap
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'order_time'?: string;
    /**
     * Delivery Date, null will default to asap ISO8601 compliant date string, defaults to current server date ,
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'order_date'?: string;
    /**
     * Meal plan type for meal plan quotation
     * @type {string}
     * @memberof QuotationRequestDTO
     */
    'meal_plan_type'?: QuotationRequestDTOMealPlanTypeEnum;
}

export const QuotationRequestDTODeliveryPaymentMethodEnum = {
    NonCash: 'non_cash',
    Cash: 'cash'
} as const;

export type QuotationRequestDTODeliveryPaymentMethodEnum = typeof QuotationRequestDTODeliveryPaymentMethodEnum[keyof typeof QuotationRequestDTODeliveryPaymentMethodEnum];
export const QuotationRequestDTODeliveryVehicleEnum = {
    Car: 'car',
    Motorcycle: 'motorcycle'
} as const;

export type QuotationRequestDTODeliveryVehicleEnum = typeof QuotationRequestDTODeliveryVehicleEnum[keyof typeof QuotationRequestDTODeliveryVehicleEnum];
export const QuotationRequestDTOMealPlanTypeEnum = {
    _3Day: '3_day',
    _5Day: '5_day'
} as const;

export type QuotationRequestDTOMealPlanTypeEnum = typeof QuotationRequestDTOMealPlanTypeEnum[keyof typeof QuotationRequestDTOMealPlanTypeEnum];

/**
 * Customer Details
 * @export
 * @interface QuotationRequestDTOCustomer
 */
export interface QuotationRequestDTOCustomer {
    /**
     * 
     * @type {CustomerDetailDTOAddress}
     * @memberof QuotationRequestDTOCustomer
     */
    'address': CustomerDetailDTOAddress;
    /**
     * address string use for delivery address
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'address_string': string;
    /**
     * A unique identifier for this customer
     * @type {string}
     * @memberof QuotationRequestDTOCustomer
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReorderDetailsClass
 */
export interface ReorderDetailsClass {
    /**
     * Item ID
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof ReorderDetailsClass
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof ReorderDetailsClass
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof ReorderDetailsClass
     */
    'is_meal_plan'?: boolean;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof ReorderDetailsClass
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Item order quantity
     * @type {number}
     * @memberof ReorderDetailsClass
     */
    'quantity': number;
    /**
     * 
     * @type {Array<OrderExtraClass>}
     * @memberof ReorderDetailsClass
     */
    'extras': Array<OrderExtraClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ReorderDetailsClass
     */
    'tags': Array<string>;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'category'?: string;
    /**
     * Indicates item type
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'type': ReorderDetailsClassTypeEnum;
    /**
     * Random unique item code
     * @type {string}
     * @memberof ReorderDetailsClass
     */
    'item_code': string;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof ReorderDetailsClass
     */
    'item_limit_per_day'?: number;
}

export const ReorderDetailsClassTypeEnum = {
    Promo: 'promo',
    Default: 'default',
    Event: 'event',
    Reservation: 'reservation'
} as const;

export type ReorderDetailsClassTypeEnum = typeof ReorderDetailsClassTypeEnum[keyof typeof ReorderDetailsClassTypeEnum];

/**
 * 
 * @export
 * @interface ReorderEntity
 */
export interface ReorderEntity {
    /**
     * Store ID
     * @type {string}
     * @memberof ReorderEntity
     */
    'store_id': string;
    /**
     * Indicates if store is currently accepting orders, or for pre orders
     * @type {boolean}
     * @memberof ReorderEntity
     */
    'is_store_open': boolean;
    /**
     * List of available items for reorder
     * @type {Array<ReorderDetailsClass>}
     * @memberof ReorderEntity
     */
    'available_items': Array<ReorderDetailsClass>;
    /**
     * List of unavailable items for reorder
     * @type {Array<ReorderDetailsClass>}
     * @memberof ReorderEntity
     */
    'unavailable_items': Array<ReorderDetailsClass>;
    /**
     * Indicates store supports pre order
     * @type {boolean}
     * @memberof ReorderEntity
     */
    'pre_order_available': boolean;
    /**
     * 
     * @type {ReorderEntityStatus}
     * @memberof ReorderEntity
     */
    'status': ReorderEntityStatus;
    /**
     * 
     * @type {ReorderEntityPlan}
     * @memberof ReorderEntity
     */
    'plan': ReorderEntityPlan;
}
/**
 * Suggested re order plan
 * @export
 * @interface ReorderEntityPlan
 */
export interface ReorderEntityPlan {
    /**
     * Order dates for the planned meal plan
     * @type {Array<string>}
     * @memberof ReorderEntityPlan
     */
    'meal_plan_dates'?: Array<string>;
    /**
     * Order type pre selected for reorder, defaults to delivery and falls back to pickup
     * @type {string}
     * @memberof ReorderEntityPlan
     */
    'order_type'?: ReorderEntityPlanOrderTypeEnum;
    /**
     * Order date pre selected for reorder
     * @type {string}
     * @memberof ReorderEntityPlan
     */
    'order_date'?: string;
    /**
     * Order time pre selected for reorder
     * @type {string}
     * @memberof ReorderEntityPlan
     */
    'order_time'?: string;
    /**
     * Items available for pre order
     * @type {Array<ReorderDetailsClass>}
     * @memberof ReorderEntityPlan
     */
    'items'?: Array<ReorderDetailsClass>;
}

export const ReorderEntityPlanOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    Digital: 'digital',
    Reservation: 'reservation'
} as const;

export type ReorderEntityPlanOrderTypeEnum = typeof ReorderEntityPlanOrderTypeEnum[keyof typeof ReorderEntityPlanOrderTypeEnum];

/**
 * Pre evaluated result if you continue with reordering
 * @export
 * @interface ReorderEntityStatus
 */
export interface ReorderEntityStatus {
    /**
     * Indicates reorder status if pushed through
     * @type {boolean}
     * @memberof ReorderEntityStatus
     */
    'possible': boolean;
    /**
     * List of conditions the reorder will encounter
     * @type {Array<string>}
     * @memberof ReorderEntityStatus
     */
    'reasons': Array<ReorderEntityStatusReasonsEnum>;
}

export const ReorderEntityStatusReasonsEnum = {
    StoreOpen: 'store_open',
    StoreClosed: 'store_closed',
    StoreSupportsPreOrder: 'store_supports_pre_order',
    AvailableItemsEmpty: 'available_items_empty',
    OrderTypeDifferent: 'order_type_different',
    MealPlanOngoing: 'meal_plan_ongoing',
    MealPlanUnavailable: 'meal_plan_unavailable',
    DeliveryUnavailable: 'delivery_unavailable'
} as const;

export type ReorderEntityStatusReasonsEnum = typeof ReorderEntityStatusReasonsEnum[keyof typeof ReorderEntityStatusReasonsEnum];

/**
 * 
 * @export
 * @interface ReservationContact
 */
export interface ReservationContact {
    /**
     * Customer first name
     * @type {string}
     * @memberof ReservationContact
     */
    'first_name': string;
    /**
     * Customer last name
     * @type {string}
     * @memberof ReservationContact
     */
    'last_name': string;
    /**
     * Valid personal or business email address
     * @type {string}
     * @memberof ReservationContact
     */
    'email': string;
    /**
     * Valid mobile number
     * @type {string}
     * @memberof ReservationContact
     */
    'mobile_number': string;
    /**
     * Customer ID that you want us to save for you, optional so you can pass guest users as well
     * @type {string}
     * @memberof ReservationContact
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReservationTableClass
 */
export interface ReservationTableClass {
    /**
     * ID of the table
     * @type {string}
     * @memberof ReservationTableClass
     */
    'id': string;
    /**
     * 
     * @type {ReservationTableClassItem}
     * @memberof ReservationTableClass
     */
    'item': ReservationTableClassItem;
    /**
     * Max seats that can be reserved per reservation
     * @type {number}
     * @memberof ReservationTableClass
     */
    'maximum': number;
    /**
     * Min seats that can be reserved per reservation
     * @type {number}
     * @memberof ReservationTableClass
     */
    'minimum': number;
    /**
     * Table name
     * @type {string}
     * @memberof ReservationTableClass
     */
    'name': string;
}
/**
 * Item to be reserved
 * @export
 * @interface ReservationTableClassItem
 */
export interface ReservationTableClassItem {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'id': string;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ReservationTableClassItem
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ReservationTableClassItem
     */
    'tags': Array<string>;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ReservationTableClassItem
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ReservationTableClassItem
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ReservationTableClassItem
     */
    'visible'?: boolean;
    /**
     * Indicates item type
     * @type {string}
     * @memberof ReservationTableClassItem
     */
    'type': ReservationTableClassItemTypeEnum;
}

export const ReservationTableClassItemTypeEnum = {
    Promo: 'promo',
    Default: 'default',
    Event: 'event',
    Reservation: 'reservation'
} as const;

export type ReservationTableClassItemTypeEnum = typeof ReservationTableClassItemTypeEnum[keyof typeof ReservationTableClassItemTypeEnum];

/**
 * 
 * @export
 * @interface SearchStoreDTO
 */
export interface SearchStoreDTO {
    /**
     * 
     * @type {SearchStoreDTOLocationPoint}
     * @memberof SearchStoreDTO
     */
    'location_point'?: SearchStoreDTOLocationPoint;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'order_date'?: string;
    /**
     * Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'order_time'?: string;
    /**
     * General search key name for \"store name\",\"item name\", \"item description\"
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'name'?: string;
    /**
     * Store tags filter comma separated
     * @type {Array<string>}
     * @memberof SearchStoreDTO
     */
    'tags'?: Array<string>;
    /**
     * Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
     * @type {boolean}
     * @memberof SearchStoreDTO
     */
    'open_only'?: boolean;
    /**
     * Store supported fulfillment service
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'order_type'?: SearchStoreDTOOrderTypeEnum;
    /**
     * Filter store via id
     * @type {Array<string>}
     * @memberof SearchStoreDTO
     */
    'ids'?: Array<string>;
    /**
     * Custom data-driven filters
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'funnel'?: SearchStoreDTOFunnelEnum;
    /**
     * Product Type filter
     * @type {string}
     * @memberof SearchStoreDTO
     */
    'product_type'?: SearchStoreDTOProductTypeEnum;
    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof SearchStoreDTO
     */
    'limit'?: number;
    /**
     * The number of records to skip
     * @type {number}
     * @memberof SearchStoreDTO
     */
    'offset'?: number;
}

export const SearchStoreDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup',
    Digital: 'digital',
    Reservation: 'reservation'
} as const;

export type SearchStoreDTOOrderTypeEnum = typeof SearchStoreDTOOrderTypeEnum[keyof typeof SearchStoreDTOOrderTypeEnum];
export const SearchStoreDTOFunnelEnum = {
    PopularDay: 'popular_day'
} as const;

export type SearchStoreDTOFunnelEnum = typeof SearchStoreDTOFunnelEnum[keyof typeof SearchStoreDTOFunnelEnum];
export const SearchStoreDTOProductTypeEnum = {
    Food: 'food',
    NonFood: 'non-food'
} as const;

export type SearchStoreDTOProductTypeEnum = typeof SearchStoreDTOProductTypeEnum[keyof typeof SearchStoreDTOProductTypeEnum];

/**
 * Optional location for kilometer distance search
 * @export
 * @interface SearchStoreDTOLocationPoint
 */
export interface SearchStoreDTOLocationPoint {
    /**
     * Maximum store delivery distance in kilometers
     * @type {number}
     * @memberof SearchStoreDTOLocationPoint
     */
    'max_radius': number;
    /**
     * Coordinate\'s longitude
     * @type {number}
     * @memberof SearchStoreDTOLocationPoint
     */
    'lng': number;
    /**
     * Coordinate\'s latitude
     * @type {number}
     * @memberof SearchStoreDTOLocationPoint
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface StoreClass
 */
export interface StoreClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreClass
     */
    'banner': string;
    /**
     * Store order opening buffer, this indicates if the store accepts order even before opening hour, defaults to 0 if is_accepting_in_advanced_orders is true e.g. If store opening hour is 09:00 and opening_hour_buffer = 30 then you can start accepting order at 08:30 for both ASAP (time assigned will still be 09:00) and pre orders
     * @type {number}
     * @memberof StoreClass
     */
    'opening_hour_buffer': number;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreClass
     */
    'delivery_distance_limit'?: number;
    /**
     * Store accepts curbside delivery
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_curbside_active': boolean;
    /**
     * Store accepts pickup order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_pickup_active': boolean;
    /**
     * Store accepts delivery order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_delivery_active': boolean;
    /**
     * Store accepts mealplan order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_meal_plan_active': boolean;
    /**
     * Meal plan discount offered, 0 means no discounts for meal plan items
     * @type {number}
     * @memberof StoreClass
     */
    'meal_plan_discount': number;
    /**
     * Store accepts dine in order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_dine_in_active': boolean;
    /**
     * Total allowed number of items purchased on a store per day
     * @type {number}
     * @memberof StoreClass
     */
    'store_item_limit_per_day': number;
    /**
     * Indicates if a store accepts and process orders any time of the day
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_open_24_hours': boolean;
    /**
     * List of dates that indicates the store as closed and will NOT accept orders
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'off_dates': Array<string>;
    /**
     * Discount applied to the delivery cost for each day of the meal plan orders. 0 means no discount\"
     * @type {number}
     * @memberof StoreClass
     */
    'free_delivery_amount': number;
    /**
     * Additional Charges set by the store
     * @type {Array<AdditionalCharge>}
     * @memberof StoreClass
     */
    'additional_charges': Array<AdditionalCharge>;
    /**
     * Available delivery payment method
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'delivery_payment_methods': Array<string>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreClass
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof StoreClass
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof StoreClass
     */
    'partner_banner': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled, if set to true it means you can accept order anytime until days_accepting_in_advanced_orders
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_accepting_in_advanced_orders': boolean;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StoreClass
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StoreClass
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Designated time for meal plan in military time
     * @type {string}
     * @memberof StoreClass
     */
    'meal_plan_order_time': string;
}
/**
 * 
 * @export
 * @interface StoreDetailsClass
 */
export interface StoreDetailsClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'banner': string;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof StoreDetailsClass
     */
    'partner_banner': string;
}
/**
 * 
 * @export
 * @interface StoreEventClass
 */
export interface StoreEventClass {
    /**
     * Event id
     * @type {string}
     * @memberof StoreEventClass
     */
    'id': string;
    /**
     * Event promotion image url
     * @type {string}
     * @memberof StoreEventClass
     */
    'image': string;
    /**
     * 
     * @type {StoreEventClassTickets}
     * @memberof StoreEventClass
     */
    'tickets': StoreEventClassTickets;
    /**
     * 
     * @type {StoreEventClassTimeSlots}
     * @memberof StoreEventClass
     */
    'time_slots': StoreEventClassTimeSlots;
    /**
     * Event name
     * @type {string}
     * @memberof StoreEventClass
     */
    'name': string;
    /**
     * Indicates event exclusivity
     * @type {string}
     * @memberof StoreEventClass
     */
    'status': string;
    /**
     * Event description
     * @type {string}
     * @memberof StoreEventClass
     */
    'description': string;
    /**
     * Event cancellation policy
     * @type {string}
     * @memberof StoreEventClass
     */
    'cancellation_policy': string;
    /**
     * Event dress code
     * @type {string}
     * @memberof StoreEventClass
     */
    'dress_code': string;
    /**
     * Distance from location_point to Store Distance in meters
     * @type {number}
     * @memberof StoreEventClass
     */
    'distance': number;
    /**
     * Event human readable address
     * @type {string}
     * @memberof StoreEventClass
     */
    'location_address': string;
    /**
     * Event geo location - lng,lat
     * @type {string}
     * @memberof StoreEventClass
     */
    'location': string;
    /**
     * Event start date
     * @type {string}
     * @memberof StoreEventClass
     */
    'start_date': string;
    /**
     * Event end date
     * @type {string}
     * @memberof StoreEventClass
     */
    'end_date': string;
    /**
     * Days of the week when the event is available 0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday
     * @type {Array<number>}
     * @memberof StoreEventClass
     */
    'available_days': Array<number>;
    /**
     * Cutoff time for ordering the event in minutes 0 = no cutoff
     * @type {number}
     * @memberof StoreEventClass
     */
    'ordering_cutoff': number;
}
/**
 * Event tickets and price list
 * @export
 * @interface StoreEventClassTickets
 */
export interface StoreEventClassTickets {
    /**
     * 
     * @type {EventTicketClassItem}
     * @memberof StoreEventClassTickets
     */
    'item': EventTicketClassItem;
    /**
     * Event seating capacity
     * @type {number}
     * @memberof StoreEventClassTickets
     */
    'capacity': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof StoreEventClassTickets
     */
    'time_slots': Array<string>;
}
/**
 * Event time slots
 * @export
 * @interface StoreEventClassTimeSlots
 */
export interface StoreEventClassTimeSlots {
    /**
     * Time slot id
     * @type {string}
     * @memberof StoreEventClassTimeSlots
     */
    'id': string;
    /**
     * Indicates possible event ticket time inclusion scope
     * @type {string}
     * @memberof StoreEventClassTimeSlots
     */
    'start_time': string;
    /**
     * Indicates possible event ticket time inclusion scope
     * @type {string}
     * @memberof StoreEventClassTimeSlots
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface StoreEventsEntity
 */
export interface StoreEventsEntity {
    /**
     * Indicates if there is a page after the current one
     * @type {boolean}
     * @memberof StoreEventsEntity
     */
    'has_next_page': boolean;
    /**
     * Indicates if there is a page before the current one
     * @type {boolean}
     * @memberof StoreEventsEntity
     */
    'has_prev_page': boolean;
    /**
     * Total number of pages according to limit and result
     * @type {number}
     * @memberof StoreEventsEntity
     */
    'total_pages': number;
    /**
     * Total number of records found against the query
     * @type {number}
     * @memberof StoreEventsEntity
     */
    'total_records': number;
    /**
     * 
     * @type {Array<StoreEventClass>}
     * @memberof StoreEventsEntity
     */
    'result': Array<StoreEventClass>;
    /**
     * Indicates current page
     * @type {number}
     * @memberof StoreEventsEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface StoreHoursClass
 */
export interface StoreHoursClass {
    /**
     * Indicates if the store is open on the specific day
     * @type {boolean}
     * @memberof StoreHoursClass
     */
    'is_open': boolean;
    /**
     * Day of the week 0 = Sunday, 1 = Monday , 2 = Tuesday...
     * @type {string}
     * @memberof StoreHoursClass
     */
    'day': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'opening': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'closing': string;
}
/**
 * 
 * @export
 * @interface StoreMenuClass
 */
export interface StoreMenuClass {
    /**
     * Store ID
     * @type {string}
     * @memberof StoreMenuClass
     */
    'id': string;
    /**
     * Store menu grouped and ordered by category
     * @type {Array<MenuClass>}
     * @memberof StoreMenuClass
     */
    'menu': Array<MenuClass>;
    /**
     * Store category list
     * @type {Array<CategoryClass>}
     * @memberof StoreMenuClass
     */
    'categories': Array<CategoryClass>;
    /**
     * Helper for expected meal plan deliveries dates
     * @type {Array<string>}
     * @memberof StoreMenuClass
     */
    'meal_plan_dates': Array<string>;
}
/**
 * 
 * @export
 * @interface StoreOrderDateTimeOptions
 */
export interface StoreOrderDateTimeOptions {
    /**
     * Time in Pickup API supported format
     * @type {string}
     * @memberof StoreOrderDateTimeOptions
     */
    'value': string;
    /**
     * Time slot start, iso format
     * @type {string}
     * @memberof StoreOrderDateTimeOptions
     */
    'start'?: string;
    /**
     * Time slot end, iso format
     * @type {string}
     * @memberof StoreOrderDateTimeOptions
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface StoreOrderDates
 */
export interface StoreOrderDates {
    /**
     * Date in Pickup API supported format
     * @type {string}
     * @memberof StoreOrderDates
     */
    'value': string;
    /**
     * Date in ISO format
     * @type {string}
     * @memberof StoreOrderDates
     */
    'iso': string;
    /**
     * Time options list
     * @type {Array<StoreOrderDateTimeOptions>}
     * @memberof StoreOrderDates
     */
    'time_options': Array<StoreOrderDateTimeOptions>;
}
/**
 * 
 * @export
 * @interface StoreOrderDatesEntity
 */
export interface StoreOrderDatesEntity {
    /**
     * 
     * @type {Array<StoreOrderDates>}
     * @memberof StoreOrderDatesEntity
     */
    'dates': Array<StoreOrderDates>;
}
/**
 * 
 * @export
 * @interface StorePartialClass
 */
export interface StorePartialClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StorePartialClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StorePartialClass
     */
    'banner': string;
    /**
     * Store order opening buffer, this indicates if the store accepts order even before opening hour, defaults to 0 if is_accepting_in_advanced_orders is true e.g. If store opening hour is 09:00 and opening_hour_buffer = 30 then you can start accepting order at 08:30 for both ASAP (time assigned will still be 09:00) and pre orders
     * @type {number}
     * @memberof StorePartialClass
     */
    'opening_hour_buffer': number;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StorePartialClass
     */
    'delivery_distance_limit'?: number;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StorePartialClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StorePartialClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof StorePartialClass
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof StorePartialClass
     */
    'partner_banner': string;
    /**
     * Store description
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StorePartialClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StorePartialClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StorePartialClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StorePartialClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled, if set to true it means you can accept order anytime until days_accepting_in_advanced_orders
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_accepting_in_advanced_orders': boolean;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StorePartialClass
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StorePartialClass
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Designated time for meal plan in military time
     * @type {string}
     * @memberof StorePartialClass
     */
    'meal_plan_order_time': string;
}
/**
 * 
 * @export
 * @interface StoreReservationClass
 */
export interface StoreReservationClass {
    /**
     * 
     * @type {StoreReservationClassStore}
     * @memberof StoreReservationClass
     */
    'store': StoreReservationClassStore;
    /**
     * List of reservation types this a store offers
     * @type {Array<ReservationTableClass>}
     * @memberof StoreReservationClass
     */
    'tables': Array<ReservationTableClass>;
}
/**
 * Store information
 * @export
 * @interface StoreReservationClassStore
 */
export interface StoreReservationClassStore {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'banner': string;
    /**
     * Store order opening buffer, this indicates if the store accepts order even before opening hour, defaults to 0 if is_accepting_in_advanced_orders is true e.g. If store opening hour is 09:00 and opening_hour_buffer = 30 then you can start accepting order at 08:30 for both ASAP (time assigned will still be 09:00) and pre orders
     * @type {number}
     * @memberof StoreReservationClassStore
     */
    'opening_hour_buffer': number;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreReservationClassStore
     */
    'delivery_distance_limit'?: number;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreReservationClassStore
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'partner_banner': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreReservationClassStore
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreReservationClassStore
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled, if set to true it means you can accept order anytime until days_accepting_in_advanced_orders
     * @type {boolean}
     * @memberof StoreReservationClassStore
     */
    'is_accepting_in_advanced_orders': boolean;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StoreReservationClassStore
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StoreReservationClassStore
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Designated time for meal plan in military time
     * @type {string}
     * @memberof StoreReservationClassStore
     */
    'meal_plan_order_time': string;
}
/**
 * 
 * @export
 * @interface StoreSearchClass
 */
export interface StoreSearchClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreSearchClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreSearchClass
     */
    'banner': string;
    /**
     * Store order opening buffer, this indicates if the store accepts order even before opening hour, defaults to 0 if is_accepting_in_advanced_orders is true e.g. If store opening hour is 09:00 and opening_hour_buffer = 30 then you can start accepting order at 08:30 for both ASAP (time assigned will still be 09:00) and pre orders
     * @type {number}
     * @memberof StoreSearchClass
     */
    'opening_hour_buffer': number;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreSearchClass
     */
    'delivery_distance_limit'?: number;
    /**
     * List of items related to name
     * @type {Array<ItemPartialClass>}
     * @memberof StoreSearchClass
     */
    'searched_items'?: Array<ItemPartialClass>;
    /**
     * List of store featured promos
     * @type {Array<PromoEntity>}
     * @memberof StoreSearchClass
     */
    'featured_promos'?: Array<PromoEntity>;
    /**
     * Distance from location_point to Store Distance in Kilometers
     * @type {number}
     * @memberof StoreSearchClass
     */
    'distance'?: number;
    /**
     * Duration in Minutes from Store geo location to location_point
     * @type {number}
     * @memberof StoreSearchClass
     */
    'duration'?: number;
    /**
     * Indicates store product type
     * @type {string}
     * @memberof StoreSearchClass
     */
    'product_type'?: StoreSearchClassProductTypeEnum;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreSearchClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreSearchClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreSearchClass
     */
    'store_logo': string;
    /**
     * Store custom partner logo
     * @type {string}
     * @memberof StoreSearchClass
     */
    'partner_logo': string;
    /**
     * Store custom partner banner
     * @type {string}
     * @memberof StoreSearchClass
     */
    'partner_banner': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreSearchClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreSearchClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreSearchClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreSearchClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreSearchClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreSearchClass
     */
    'is_store_open': boolean;
    /**
     * Pre-order feature is enabled, if set to true it means you can accept order anytime until days_accepting_in_advanced_orders
     * @type {boolean}
     * @memberof StoreSearchClass
     */
    'is_accepting_in_advanced_orders': boolean;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StoreSearchClass
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StoreSearchClass
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Designated time for meal plan in military time
     * @type {string}
     * @memberof StoreSearchClass
     */
    'meal_plan_order_time': string;
}

export const StoreSearchClassProductTypeEnum = {
    Food: 'food',
    NonFood: 'non-food'
} as const;

export type StoreSearchClassProductTypeEnum = typeof StoreSearchClassProductTypeEnum[keyof typeof StoreSearchClassProductTypeEnum];

/**
 * 
 * @export
 * @interface StoreTableAvailability
 */
export interface StoreTableAvailability {
    /**
     * Indicates table\'s availability for reservation
     * @type {boolean}
     * @memberof StoreTableAvailability
     */
    'available': boolean;
}
/**
 * 
 * @export
 * @interface StoresEntity
 */
export interface StoresEntity {
    /**
     * Indicates if there is a page after the current one
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_next_page': boolean;
    /**
     * Indicates if there is a page before the current one
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_prev_page': boolean;
    /**
     * Total number of pages according to limit and result
     * @type {number}
     * @memberof StoresEntity
     */
    'total_pages': number;
    /**
     * Total number of records found against the query
     * @type {number}
     * @memberof StoresEntity
     */
    'total_records': number;
    /**
     * 
     * @type {Array<StoreSearchClass>}
     * @memberof StoresEntity
     */
    'result': Array<StoreSearchClass>;
    /**
     * Indicates current page
     * @type {number}
     * @memberof StoresEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface ThirdPartyCustomerDetail
 */
export interface ThirdPartyCustomerDetail {
    /**
     * Customer\'s first name
     * @type {string}
     * @memberof ThirdPartyCustomerDetail
     */
    'first_name': string;
    /**
     * Customer\'s last name
     * @type {string}
     * @memberof ThirdPartyCustomerDetail
     */
    'last_name': string;
    /**
     * Customer\'s phone number
     * @type {string}
     * @memberof ThirdPartyCustomerDetail
     */
    'contact_number': string;
}
/**
 * 
 * @export
 * @interface ThirdPartyPickupDTO
 */
export interface ThirdPartyPickupDTO {
    /**
     * The customer first name
     * @type {string}
     * @memberof ThirdPartyPickupDTO
     */
    'first_name': string;
    /**
     * The customer last name
     * @type {string}
     * @memberof ThirdPartyPickupDTO
     */
    'last_name': string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof ThirdPartyPickupDTO
     */
    'mobile_number': string;
}
/**
 * 
 * @export
 * @interface ValidPromoEntity
 */
export interface ValidPromoEntity {
    /**
     * Type of this promo
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'type': ValidPromoEntityTypeEnum;
    /**
     * 
     * @type {ValidPromoEntityPromo}
     * @memberof ValidPromoEntity
     */
    'promo'?: ValidPromoEntityPromo;
    /**
     * Calculated discount for delivery fee
     * @type {number}
     * @memberof ValidPromoEntity
     */
    'delivery_discount': number;
    /**
     * Promo description
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'description'?: string;
    /**
     * Promo expiry
     * @type {string}
     * @memberof ValidPromoEntity
     */
    'end_date'?: string;
    /**
     * Minimum total amount for this promo to be valid
     * @type {number}
     * @memberof ValidPromoEntity
     */
    'minimum_purchase'?: number;
}

export const ValidPromoEntityTypeEnum = {
    AmountOff: 'amount_off',
    PercentageOff: 'percentage_off',
    FreeDelivery: 'free_delivery',
    FreeItem: 'free_item'
} as const;

export type ValidPromoEntityTypeEnum = typeof ValidPromoEntityTypeEnum[keyof typeof ValidPromoEntityTypeEnum];

/**
 * Calculated discount base on total amount
 * @export
 * @interface ValidPromoEntityPromo
 */
export interface ValidPromoEntityPromo {
    /**
     * Amount to be paid before promo is applied, used as base of calculation
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'original': number;
    /**
     * Total amount after calculated promo is applied
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'applied': number;
    /**
     * Calculated promo value deducted from original price
     * @type {number}
     * @memberof ValidPromoEntityPromo
     */
    'total': number;
    /**
     * Base promo value, if promo type is amount_off this is Php 20.00 if type is percentage_off this is 20%
     * @type {string}
     * @memberof ValidPromoEntityPromo
     */
    'value': string;
}

/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Compute cart service charge
         * @param {ComputeAddtionalChargeDTO} computeAddtionalChargeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerComputeAdditionalCharge: async (computeAddtionalChargeDTO: ComputeAddtionalChargeDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'computeAddtionalChargeDTO' is not null or undefined
            assertParamExists('cartControllerComputeAdditionalCharge', 'computeAddtionalChargeDTO', computeAddtionalChargeDTO)
            const localVarPath = `/v1/cart/additional-charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeAddtionalChargeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate: async (cartDTO: CartDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDTO' is not null or undefined
            assertParamExists('cartControllerCreate', 'cartDTO', cartDTO)
            const localVarPath = `/v1/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Compute cart service charge
         * @param {ComputeAddtionalChargeDTO} computeAddtionalChargeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerComputeAdditionalCharge(computeAddtionalChargeDTO: ComputeAddtionalChargeDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartAdditionalChargesEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerComputeAdditionalCharge(computeAddtionalChargeDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerCreate(cartDTO: CartDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerCreate(cartDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Compute cart service charge
         * @param {ComputeAddtionalChargeDTO} computeAddtionalChargeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerComputeAdditionalCharge(computeAddtionalChargeDTO: ComputeAddtionalChargeDTO, options?: any): AxiosPromise<CartAdditionalChargesEntity> {
            return localVarFp.cartControllerComputeAdditionalCharge(computeAddtionalChargeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate(cartDTO: CartDTO, options?: any): AxiosPromise<CartEntity> {
            return localVarFp.cartControllerCreate(cartDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cartControllerComputeAdditionalCharge operation in CartApi.
 * @export
 * @interface CartApiCartControllerComputeAdditionalChargeRequest
 */
export interface CartApiCartControllerComputeAdditionalChargeRequest {
    /**
     * 
     * @type {ComputeAddtionalChargeDTO}
     * @memberof CartApiCartControllerComputeAdditionalCharge
     */
    readonly computeAddtionalChargeDTO: ComputeAddtionalChargeDTO
}

/**
 * Request parameters for cartControllerCreate operation in CartApi.
 * @export
 * @interface CartApiCartControllerCreateRequest
 */
export interface CartApiCartControllerCreateRequest {
    /**
     * 
     * @type {CartDTO}
     * @memberof CartApiCartControllerCreate
     */
    readonly cartDTO: CartDTO
}

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Compute cart service charge
     * @param {CartApiCartControllerComputeAdditionalChargeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerComputeAdditionalCharge(requestParameters: CartApiCartControllerComputeAdditionalChargeRequest, options?: AxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerComputeAdditionalCharge(requestParameters.computeAddtionalChargeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create cart
     * @param {CartApiCartControllerCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerCreate(requestParameters: CartApiCartControllerCreateRequest, options?: AxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerCreate(requestParameters.cartDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo(options?: any): AxiosPromise<object> {
            return localVarFp.appControllerGetServerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get server information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetServerInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeliveryApi - axios parameter creator
 * @export
 */
export const DeliveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryControllerGetQuotation: async (quotationRequestDTO: QuotationRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quotationRequestDTO' is not null or undefined
            assertParamExists('deliveryControllerGetQuotation', 'quotationRequestDTO', quotationRequestDTO)
            const localVarPath = `/v1/delivery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quotationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeliveryApi - functional programming interface
 * @export
 */
export const DeliveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeliveryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryControllerGetQuotation(quotationRequestDTO: QuotationRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryQuotationResultEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryControllerGetQuotation(quotationRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeliveryApi - factory interface
 * @export
 */
export const DeliveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeliveryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Quotation
         * @param {QuotationRequestDTO} quotationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryControllerGetQuotation(quotationRequestDTO: QuotationRequestDTO, options?: any): AxiosPromise<DeliveryQuotationResultEntity> {
            return localVarFp.deliveryControllerGetQuotation(quotationRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deliveryControllerGetQuotation operation in DeliveryApi.
 * @export
 * @interface DeliveryApiDeliveryControllerGetQuotationRequest
 */
export interface DeliveryApiDeliveryControllerGetQuotationRequest {
    /**
     * 
     * @type {QuotationRequestDTO}
     * @memberof DeliveryApiDeliveryControllerGetQuotation
     */
    readonly quotationRequestDTO: QuotationRequestDTO
}

/**
 * DeliveryApi - object-oriented interface
 * @export
 * @class DeliveryApi
 * @extends {BaseAPI}
 */
export class DeliveryApi extends BaseAPI {
    /**
     * 
     * @summary Get Quotation
     * @param {DeliveryApiDeliveryControllerGetQuotationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeliveryApi
     */
    public deliveryControllerGetQuotation(requestParameters: DeliveryApiDeliveryControllerGetQuotationRequest, options?: AxiosRequestConfig) {
        return DeliveryApiFp(this.configuration).deliveryControllerGetQuotation(requestParameters.quotationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search for events
         * @param {string} [store] ID of store
         * @param {string} [price] Minimum event price filter
         * @param {string} [location] Event distance search center, this will be use to filter events base on your user location
         * @param {string} [eventDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [time] 
         * @param {number} [partySize] 
         * @param {string} [keyword] General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
         * @param {Array<string>} [sort] Sort result with key,strategy pattern
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsControllerFetchEvents: async (store?: string, price?: string, location?: string, eventDate?: string, time?: string, partySize?: number, keyword?: string, sort?: Array<string>, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/events/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (store !== undefined) {
                localVarQueryParameter['store'] = store;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (eventDate !== undefined) {
                localVarQueryParameter['event_date'] = eventDate;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (partySize !== undefined) {
                localVarQueryParameter['party_size'] = partySize;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of available tickets in an event according to time slot
         * @param {string} id ID of the event
         * @param {string} date Date to be validated against the event
         * @param {number} partySize Intended party to size to be validated against the event
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsControllerGetEventAvailability: async (id: string, date: string, partySize: number, time?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsControllerGetEventAvailability', 'id', id)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('eventsControllerGetEventAvailability', 'date', date)
            // verify required parameter 'partySize' is not null or undefined
            assertParamExists('eventsControllerGetEventAvailability', 'partySize', partySize)
            const localVarPath = `/v1/events/{id}/available`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (partySize !== undefined) {
                localVarQueryParameter['party_size'] = partySize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event information
         * @param {string} id ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsControllerGetEventInformation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsControllerGetEventInformation', 'id', id)
            const localVarPath = `/v1/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search for events
         * @param {string} [store] ID of store
         * @param {string} [price] Minimum event price filter
         * @param {string} [location] Event distance search center, this will be use to filter events base on your user location
         * @param {string} [eventDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [time] 
         * @param {number} [partySize] 
         * @param {string} [keyword] General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
         * @param {Array<string>} [sort] Sort result with key,strategy pattern
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsControllerFetchEvents(store?: string, price?: string, location?: string, eventDate?: string, time?: string, partySize?: number, keyword?: string, sort?: Array<string>, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsControllerFetchEvents(store, price, location, eventDate, time, partySize, keyword, sort, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of available tickets in an event according to time slot
         * @param {string} id ID of the event
         * @param {string} date Date to be validated against the event
         * @param {number} partySize Intended party to size to be validated against the event
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsControllerGetEventAvailability(id: string, date: string, partySize: number, time?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAvailabilityClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsControllerGetEventAvailability(id, date, partySize, time, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event information
         * @param {string} id ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsControllerGetEventInformation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsControllerGetEventInformation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Search for events
         * @param {string} [store] ID of store
         * @param {string} [price] Minimum event price filter
         * @param {string} [location] Event distance search center, this will be use to filter events base on your user location
         * @param {string} [eventDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [time] 
         * @param {number} [partySize] 
         * @param {string} [keyword] General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
         * @param {Array<string>} [sort] Sort result with key,strategy pattern
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsControllerFetchEvents(store?: string, price?: string, location?: string, eventDate?: string, time?: string, partySize?: number, keyword?: string, sort?: Array<string>, limit?: number, offset?: number, options?: any): AxiosPromise<EventEntity> {
            return localVarFp.eventsControllerFetchEvents(store, price, location, eventDate, time, partySize, keyword, sort, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of available tickets in an event according to time slot
         * @param {string} id ID of the event
         * @param {string} date Date to be validated against the event
         * @param {number} partySize Intended party to size to be validated against the event
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsControllerGetEventAvailability(id: string, date: string, partySize: number, time?: string, options?: any): AxiosPromise<EventAvailabilityClass> {
            return localVarFp.eventsControllerGetEventAvailability(id, date, partySize, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event information
         * @param {string} id ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsControllerGetEventInformation(id: string, options?: any): AxiosPromise<EventClass> {
            return localVarFp.eventsControllerGetEventInformation(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for eventsControllerFetchEvents operation in EventApi.
 * @export
 * @interface EventApiEventsControllerFetchEventsRequest
 */
export interface EventApiEventsControllerFetchEventsRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly store?: string

    /**
     * Minimum event price filter
     * @type {string}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly price?: string

    /**
     * Event distance search center, this will be use to filter events base on your user location
     * @type {string}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly location?: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly eventDate?: string

    /**
     * 
     * @type {string}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly time?: string

    /**
     * 
     * @type {number}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly partySize?: number

    /**
     * General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
     * @type {string}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly keyword?: string

    /**
     * Sort result with key,strategy pattern
     * @type {Array<string>}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly sort?: Array<string>

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof EventApiEventsControllerFetchEvents
     */
    readonly offset?: number
}

/**
 * Request parameters for eventsControllerGetEventAvailability operation in EventApi.
 * @export
 * @interface EventApiEventsControllerGetEventAvailabilityRequest
 */
export interface EventApiEventsControllerGetEventAvailabilityRequest {
    /**
     * ID of the event
     * @type {string}
     * @memberof EventApiEventsControllerGetEventAvailability
     */
    readonly id: string

    /**
     * Date to be validated against the event
     * @type {string}
     * @memberof EventApiEventsControllerGetEventAvailability
     */
    readonly date: string

    /**
     * Intended party to size to be validated against the event
     * @type {number}
     * @memberof EventApiEventsControllerGetEventAvailability
     */
    readonly partySize: number

    /**
     * 
     * @type {string}
     * @memberof EventApiEventsControllerGetEventAvailability
     */
    readonly time?: string
}

/**
 * Request parameters for eventsControllerGetEventInformation operation in EventApi.
 * @export
 * @interface EventApiEventsControllerGetEventInformationRequest
 */
export interface EventApiEventsControllerGetEventInformationRequest {
    /**
     * ID of the event
     * @type {string}
     * @memberof EventApiEventsControllerGetEventInformation
     */
    readonly id: string
}

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Search for events
     * @param {EventApiEventsControllerFetchEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsControllerFetchEvents(requestParameters: EventApiEventsControllerFetchEventsRequest = {}, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsControllerFetchEvents(requestParameters.store, requestParameters.price, requestParameters.location, requestParameters.eventDate, requestParameters.time, requestParameters.partySize, requestParameters.keyword, requestParameters.sort, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of available tickets in an event according to time slot
     * @param {EventApiEventsControllerGetEventAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsControllerGetEventAvailability(requestParameters: EventApiEventsControllerGetEventAvailabilityRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsControllerGetEventAvailability(requestParameters.id, requestParameters.date, requestParameters.partySize, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event information
     * @param {EventApiEventsControllerGetEventInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventsControllerGetEventInformation(requestParameters: EventApiEventsControllerGetEventInformationRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).eventsControllerGetEventInformation(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId: async (id: string, storeId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerAggregateId', 'id', id)
            const localVarPath = `/v1/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch: async (name?: string, storeId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity: async (id: string, orderDate?: string, orderTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerGetSoldQuantity', 'id', id)
            const localVarPath = `/v1/item/{id}/stock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateId(id: string, storeId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateId(id, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateSearch(name, storeId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemInventoryEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerGetSoldQuantity(id, orderDate, orderTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {string} [storeId] ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId(id: string, storeId?: string, options?: any): AxiosPromise<ItemClass> {
            return localVarFp.itemControllerAggregateId(id, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ItemsEntity> {
            return localVarFp.itemControllerAggregateSearch(name, storeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: any): AxiosPromise<ItemInventoryEntity> {
            return localVarFp.itemControllerGetSoldQuantity(id, orderDate, orderTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for itemControllerAggregateId operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateIdRequest
 */
export interface ItemApiItemControllerAggregateIdRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly id: string

    /**
     * ID of store
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly storeId?: string
}

/**
 * Request parameters for itemControllerAggregateSearch operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateSearchRequest
 */
export interface ItemApiItemControllerAggregateSearchRequest {
    /**
     * Item name search key, part of full name
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly name?: string

    /**
     * Filter items via store ID
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly storeId?: string

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly offset?: number
}

/**
 * Request parameters for itemControllerGetSoldQuantity operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerGetSoldQuantityRequest
 */
export interface ItemApiItemControllerGetSoldQuantityRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly id: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderDate?: string

    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderTime?: string
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Get item data
     * @param {ItemApiItemControllerAggregateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateId(requestParameters: ItemApiItemControllerAggregateIdRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateId(requestParameters.id, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search items by name
     * @param {ItemApiItemControllerAggregateSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateSearch(requestParameters: ItemApiItemControllerAggregateSearchRequest = {}, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateSearch(requestParameters.name, requestParameters.storeId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get inventory of an item
     * @param {ItemApiItemControllerGetSoldQuantityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerGetSoldQuantity(requestParameters: ItemApiItemControllerGetSoldQuantityRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerGetSoldQuantity(requestParameters.id, requestParameters.orderDate, requestParameters.orderTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update curbside customer arrival status
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerCurbsideArrived: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersControllerCurbsideArrived', 'orderId', orderId)
            const localVarPath = `/v1/orders/curbside/{order_id}/arrived`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order status update
         * @param {string} transactionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFetchStatus: async (transactionNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionNumber' is not null or undefined
            assertParamExists('ordersControllerFetchStatus', 'transactionNumber', transactionNumber)
            const localVarPath = `/v1/orders/{transaction_number}`
                .replace(`{${"transaction_number"}}`, encodeURIComponent(String(transactionNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation'} [orderType] Order type
         * @param {boolean} [mealPlan] Toggle meal plan filter, returns orders that are part of a meal plan ONLY if set to true Defaults to false
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFind: async (id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation', mealPlan?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersControllerFind', 'id', id)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (maxOrderDate !== undefined) {
                localVarQueryParameter['max_order_date'] = maxOrderDate;
            }

            if (minOrderDate !== undefined) {
                localVarQueryParameter['min_order_date'] = minOrderDate;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (mealPlan !== undefined) {
                localVarQueryParameter['meal_plan'] = mealPlan;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get re-order plan
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerReorder: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersControllerReorder', 'orderId', orderId)
            const localVarPath = `/v1/orders/{order_id}/reorder`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update curbside customer arrival status
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersControllerCurbsideArrived(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurbsideArrivalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersControllerCurbsideArrived(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order status update
         * @param {string} transactionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersControllerFetchStatus(transactionNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderPartialClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersControllerFetchStatus(transactionNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation'} [orderType] Order type
         * @param {boolean} [mealPlan] Toggle meal plan filter, returns orders that are part of a meal plan ONLY if set to true Defaults to false
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersControllerFind(id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation', mealPlan?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersControllerFind(id, maxOrderDate, minOrderDate, status, orderType, mealPlan, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get re-order plan
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersControllerReorder(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReorderEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersControllerReorder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Update curbside customer arrival status
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerCurbsideArrived(orderId: string, options?: any): AxiosPromise<CurbsideArrivalResponse> {
            return localVarFp.ordersControllerCurbsideArrived(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order status update
         * @param {string} transactionNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFetchStatus(transactionNumber: string, options?: any): AxiosPromise<OrderPartialClass> {
            return localVarFp.ordersControllerFetchStatus(transactionNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get customer order history
         * @param {string} id Customer ID that you passed to us
         * @param {string} [maxOrderDate] ISO8601 compliant order date string
         * @param {string} [minOrderDate] ISO8601 compliant order date string
         * @param {'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending'} [status] Order status filter
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation'} [orderType] Order type
         * @param {boolean} [mealPlan] Toggle meal plan filter, returns orders that are part of a meal plan ONLY if set to true Defaults to false
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerFind(id: string, maxOrderDate?: string, minOrderDate?: string, status?: 'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending', orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation', mealPlan?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<OrderEntity> {
            return localVarFp.ordersControllerFind(id, maxOrderDate, minOrderDate, status, orderType, mealPlan, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get re-order plan
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersControllerReorder(orderId: string, options?: any): AxiosPromise<ReorderEntity> {
            return localVarFp.ordersControllerReorder(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ordersControllerCurbsideArrived operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersControllerCurbsideArrivedRequest
 */
export interface OrdersApiOrdersControllerCurbsideArrivedRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiOrdersControllerCurbsideArrived
     */
    readonly orderId: string
}

/**
 * Request parameters for ordersControllerFetchStatus operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersControllerFetchStatusRequest
 */
export interface OrdersApiOrdersControllerFetchStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiOrdersControllerFetchStatus
     */
    readonly transactionNumber: string
}

/**
 * Request parameters for ordersControllerFind operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersControllerFindRequest
 */
export interface OrdersApiOrdersControllerFindRequest {
    /**
     * Customer ID that you passed to us
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly id: string

    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly maxOrderDate?: string

    /**
     * ISO8601 compliant order date string
     * @type {string}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly minOrderDate?: string

    /**
     * Order status filter
     * @type {'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending'}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly status?: 'new' | 'out_for_delivery' | 'accepted' | 'ready' | 'cancelled' | 'completed' | 'refunded' | 'expired' | 'payment_failed' | 'payment_pending'

    /**
     * Order type
     * @type {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation'}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'digital' | 'reservation'

    /**
     * Toggle meal plan filter, returns orders that are part of a meal plan ONLY if set to true Defaults to false
     * @type {boolean}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly mealPlan?: boolean

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof OrdersApiOrdersControllerFind
     */
    readonly offset?: number
}

/**
 * Request parameters for ordersControllerReorder operation in OrdersApi.
 * @export
 * @interface OrdersApiOrdersControllerReorderRequest
 */
export interface OrdersApiOrdersControllerReorderRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiOrdersControllerReorder
     */
    readonly orderId: string
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Update curbside customer arrival status
     * @param {OrdersApiOrdersControllerCurbsideArrivedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersControllerCurbsideArrived(requestParameters: OrdersApiOrdersControllerCurbsideArrivedRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersControllerCurbsideArrived(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order status update
     * @param {OrdersApiOrdersControllerFetchStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersControllerFetchStatus(requestParameters: OrdersApiOrdersControllerFetchStatusRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersControllerFetchStatus(requestParameters.transactionNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get customer order history
     * @param {OrdersApiOrdersControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersControllerFind(requestParameters: OrdersApiOrdersControllerFindRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersControllerFind(requestParameters.id, requestParameters.maxOrderDate, requestParameters.minOrderDate, requestParameters.status, requestParameters.orderType, requestParameters.mealPlan, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get re-order plan
     * @param {OrdersApiOrdersControllerReorderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersControllerReorder(requestParameters: OrdersApiOrdersControllerReorderRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersControllerReorder(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromoApi - axios parameter creator
 * @export
 */
export const PromoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerGetPromosByStore: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('promoControllerGetPromosByStore', 'storeId', storeId)
            const localVarPath = `/v1/promo/{store_id}`
                .replace(`{${"store_id"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerValidatePromo: async (promoDTO: PromoDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoDTO' is not null or undefined
            assertParamExists('promoControllerValidatePromo', 'promoDTO', promoDTO)
            const localVarPath = `/v1/promo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromoApi - functional programming interface
 * @export
 */
export const PromoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerGetPromosByStore(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerGetPromosByStore(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoControllerValidatePromo(promoDTO: PromoDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidPromoEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoControllerValidatePromo(promoDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromoApi - factory interface
 * @export
 */
export const PromoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of promo per store
         * @param {string} storeId Store ID of the list of promos you want to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerGetPromosByStore(storeId: string, options?: any): AxiosPromise<PromoListResponse> {
            return localVarFp.promoControllerGetPromosByStore(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate promo and get calculated result
         * @param {PromoDTO} promoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoControllerValidatePromo(promoDTO: PromoDTO, options?: any): AxiosPromise<ValidPromoEntity> {
            return localVarFp.promoControllerValidatePromo(promoDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for promoControllerGetPromosByStore operation in PromoApi.
 * @export
 * @interface PromoApiPromoControllerGetPromosByStoreRequest
 */
export interface PromoApiPromoControllerGetPromosByStoreRequest {
    /**
     * Store ID of the list of promos you want to fetch
     * @type {string}
     * @memberof PromoApiPromoControllerGetPromosByStore
     */
    readonly storeId: string
}

/**
 * Request parameters for promoControllerValidatePromo operation in PromoApi.
 * @export
 * @interface PromoApiPromoControllerValidatePromoRequest
 */
export interface PromoApiPromoControllerValidatePromoRequest {
    /**
     * 
     * @type {PromoDTO}
     * @memberof PromoApiPromoControllerValidatePromo
     */
    readonly promoDTO: PromoDTO
}

/**
 * PromoApi - object-oriented interface
 * @export
 * @class PromoApi
 * @extends {BaseAPI}
 */
export class PromoApi extends BaseAPI {
    /**
     * 
     * @summary Get list of promo per store
     * @param {PromoApiPromoControllerGetPromosByStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerGetPromosByStore(requestParameters: PromoApiPromoControllerGetPromosByStoreRequest, options?: AxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerGetPromosByStore(requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate promo and get calculated result
     * @param {PromoApiPromoControllerValidatePromoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoControllerValidatePromo(requestParameters: PromoApiPromoControllerValidatePromoRequest, options?: AxiosRequestConfig) {
        return PromoApiFp(this.configuration).promoControllerValidatePromo(requestParameters.promoDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReservationBetaApi - axios parameter creator
 * @export
 */
export const ReservationBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get table availability status
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerCheckTableAvailability: async (date: string, time: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('reservationControllerCheckTableAvailability', 'date', date)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('reservationControllerCheckTableAvailability', 'time', time)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reservationControllerCheckTableAvailability', 'id', id)
            const localVarPath = `/v1/reservation/{id}/available`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create reservation request
         * @param {CreateReservationDTO} createReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerCreateReservation: async (createReservationDTO: CreateReservationDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createReservationDTO' is not null or undefined
            assertParamExists('reservationControllerCreateReservation', 'createReservationDTO', createReservationDTO)
            const localVarPath = `/v1/reservation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReservationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of store tables available for reservation
         * @param {string} seats Intended number of seats to reserve
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {string} [store] ID of store
         * @param {string} [keyword] Search by keyword
         * @param {string} [location] Available tables distance search center, this will be use to filter Available tables base on your user location
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetStoresWithReservations: async (seats: string, date: string, time: string, store?: string, keyword?: string, location?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seats' is not null or undefined
            assertParamExists('reservationControllerGetStoresWithReservations', 'seats', seats)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('reservationControllerGetStoresWithReservations', 'date', date)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('reservationControllerGetStoresWithReservations', 'time', time)
            const localVarPath = `/v1/reservation/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (store !== undefined) {
                localVarQueryParameter['store'] = store;
            }

            if (seats !== undefined) {
                localVarQueryParameter['seats'] = seats;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReservationBetaApi - functional programming interface
 * @export
 */
export const ReservationBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReservationBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get table availability status
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerCheckTableAvailability(date: string, time: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreTableAvailability>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerCheckTableAvailability(date, time, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create reservation request
         * @param {CreateReservationDTO} createReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerCreateReservation(createReservationDTO: CreateReservationDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerCreateReservation(createReservationDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of store tables available for reservation
         * @param {string} seats Intended number of seats to reserve
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {string} [store] ID of store
         * @param {string} [keyword] Search by keyword
         * @param {string} [location] Available tables distance search center, this will be use to filter Available tables base on your user location
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reservationControllerGetStoresWithReservations(seats: string, date: string, time: string, store?: string, keyword?: string, location?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableReservationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reservationControllerGetStoresWithReservations(seats, date, time, store, keyword, location, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReservationBetaApi - factory interface
 * @export
 */
export const ReservationBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReservationBetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get table availability status
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerCheckTableAvailability(date: string, time: string, id: string, options?: any): AxiosPromise<StoreTableAvailability> {
            return localVarFp.reservationControllerCheckTableAvailability(date, time, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create reservation request
         * @param {CreateReservationDTO} createReservationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerCreateReservation(createReservationDTO: CreateReservationDTO, options?: any): AxiosPromise<CartEntity> {
            return localVarFp.reservationControllerCreateReservation(createReservationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of store tables available for reservation
         * @param {string} seats Intended number of seats to reserve
         * @param {string} date Intended date to reserve
         * @param {string} time Intended time to reserve
         * @param {string} [store] ID of store
         * @param {string} [keyword] Search by keyword
         * @param {string} [location] Available tables distance search center, this will be use to filter Available tables base on your user location
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reservationControllerGetStoresWithReservations(seats: string, date: string, time: string, store?: string, keyword?: string, location?: string, limit?: number, offset?: number, options?: any): AxiosPromise<AvailableReservationEntity> {
            return localVarFp.reservationControllerGetStoresWithReservations(seats, date, time, store, keyword, location, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reservationControllerCheckTableAvailability operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerCheckTableAvailabilityRequest
 */
export interface ReservationBetaApiReservationControllerCheckTableAvailabilityRequest {
    /**
     * Intended date to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerCheckTableAvailability
     */
    readonly date: string

    /**
     * Intended time to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerCheckTableAvailability
     */
    readonly time: string

    /**
     * 
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerCheckTableAvailability
     */
    readonly id: string
}

/**
 * Request parameters for reservationControllerCreateReservation operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerCreateReservationRequest
 */
export interface ReservationBetaApiReservationControllerCreateReservationRequest {
    /**
     * 
     * @type {CreateReservationDTO}
     * @memberof ReservationBetaApiReservationControllerCreateReservation
     */
    readonly createReservationDTO: CreateReservationDTO
}

/**
 * Request parameters for reservationControllerGetStoresWithReservations operation in ReservationBetaApi.
 * @export
 * @interface ReservationBetaApiReservationControllerGetStoresWithReservationsRequest
 */
export interface ReservationBetaApiReservationControllerGetStoresWithReservationsRequest {
    /**
     * Intended number of seats to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly seats: string

    /**
     * Intended date to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly date: string

    /**
     * Intended time to reserve
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly time: string

    /**
     * ID of store
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly store?: string

    /**
     * Search by keyword
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly keyword?: string

    /**
     * Available tables distance search center, this will be use to filter Available tables base on your user location
     * @type {string}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly location?: string

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ReservationBetaApiReservationControllerGetStoresWithReservations
     */
    readonly offset?: number
}

/**
 * ReservationBetaApi - object-oriented interface
 * @export
 * @class ReservationBetaApi
 * @extends {BaseAPI}
 */
export class ReservationBetaApi extends BaseAPI {
    /**
     * 
     * @summary Get table availability status
     * @param {ReservationBetaApiReservationControllerCheckTableAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerCheckTableAvailability(requestParameters: ReservationBetaApiReservationControllerCheckTableAvailabilityRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerCheckTableAvailability(requestParameters.date, requestParameters.time, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create reservation request
     * @param {ReservationBetaApiReservationControllerCreateReservationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerCreateReservation(requestParameters: ReservationBetaApiReservationControllerCreateReservationRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerCreateReservation(requestParameters.createReservationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of store tables available for reservation
     * @param {ReservationBetaApiReservationControllerGetStoresWithReservationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReservationBetaApi
     */
    public reservationControllerGetStoresWithReservations(requestParameters: ReservationBetaApiReservationControllerGetStoresWithReservationsRequest, options?: AxiosRequestConfig) {
        return ReservationBetaApiFp(this.configuration).reservationControllerGetStoresWithReservations(requestParameters.seats, requestParameters.date, requestParameters.time, requestParameters.store, requestParameters.keyword, requestParameters.location, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get store events
         * @param {string} id ID of store
         * @param {string} [store] ID of store
         * @param {string} [price] Minimum event price filter
         * @param {string} [location] Event distance search center, this will be use to filter events base on your user location
         * @param {string} [eventDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [time] 
         * @param {number} [partySize] 
         * @param {string} [keyword] General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
         * @param {Array<string>} [sort] Sort result with key,strategy pattern
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchEvents: async (id: string, store?: string, price?: string, location?: string, eventDate?: string, time?: string, partySize?: number, keyword?: string, sort?: Array<string>, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerFetchEvents', 'id', id)
            const localVarPath = `/v1/store/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (store !== undefined) {
                localVarQueryParameter['store'] = store;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (eventDate !== undefined) {
                localVarQueryParameter['event_date'] = eventDate;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (partySize !== undefined) {
                localVarQueryParameter['party_size'] = partySize;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store menu
         * @param {string} id ID of store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchMenu: async (id: string, orderDate?: string, orderTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerFetchMenu', 'id', id)
            const localVarPath = `/v1/store/{id}/menu`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find store
         * @param {SearchStoreDTO} searchStoreDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind: async (searchStoreDTO: SearchStoreDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchStoreDTO' is not null or undefined
            assertParamExists('storeControllerFind', 'searchStoreDTO', searchStoreDTO)
            const localVarPath = `/v1/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchStoreDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerFindOne', 'id', id)
            const localVarPath = `/v1/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store date options
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerGetStoreDateOptions: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerGetStoreDateOptions', 'id', id)
            const localVarPath = `/v1/store/{id}/order-dates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get store events
         * @param {string} id ID of store
         * @param {string} [store] ID of store
         * @param {string} [price] Minimum event price filter
         * @param {string} [location] Event distance search center, this will be use to filter events base on your user location
         * @param {string} [eventDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [time] 
         * @param {number} [partySize] 
         * @param {string} [keyword] General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
         * @param {Array<string>} [sort] Sort result with key,strategy pattern
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFetchEvents(id: string, store?: string, price?: string, location?: string, eventDate?: string, time?: string, partySize?: number, keyword?: string, sort?: Array<string>, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreEventsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFetchEvents(id, store, price, location, eventDate, time, partySize, keyword, sort, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store menu
         * @param {string} id ID of store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFetchMenu(id: string, orderDate?: string, orderTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreMenuClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFetchMenu(id, orderDate, orderTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find store
         * @param {SearchStoreDTO} searchStoreDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFind(searchStoreDTO: SearchStoreDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFind(searchStoreDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store date options
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerGetStoreDateOptions(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreOrderDatesEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerGetStoreDateOptions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Get store events
         * @param {string} id ID of store
         * @param {string} [store] ID of store
         * @param {string} [price] Minimum event price filter
         * @param {string} [location] Event distance search center, this will be use to filter events base on your user location
         * @param {string} [eventDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [time] 
         * @param {number} [partySize] 
         * @param {string} [keyword] General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
         * @param {Array<string>} [sort] Sort result with key,strategy pattern
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchEvents(id: string, store?: string, price?: string, location?: string, eventDate?: string, time?: string, partySize?: number, keyword?: string, sort?: Array<string>, limit?: number, offset?: number, options?: any): AxiosPromise<StoreEventsEntity> {
            return localVarFp.storeControllerFetchEvents(id, store, price, location, eventDate, time, partySize, keyword, sort, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store menu
         * @param {string} id ID of store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchMenu(id: string, orderDate?: string, orderTime?: string, options?: any): AxiosPromise<StoreMenuClass> {
            return localVarFp.storeControllerFetchMenu(id, orderDate, orderTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find store
         * @param {SearchStoreDTO} searchStoreDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind(searchStoreDTO: SearchStoreDTO, options?: any): AxiosPromise<StoresEntity> {
            return localVarFp.storeControllerFind(searchStoreDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne(id: string, options?: any): AxiosPromise<StoreClass> {
            return localVarFp.storeControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store date options
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerGetStoreDateOptions(id: string, options?: any): AxiosPromise<StoreOrderDatesEntity> {
            return localVarFp.storeControllerGetStoreDateOptions(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeControllerFetchEvents operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFetchEventsRequest
 */
export interface StoreApiStoreControllerFetchEventsRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly id: string

    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly store?: string

    /**
     * Minimum event price filter
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly price?: string

    /**
     * Event distance search center, this will be use to filter events base on your user location
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly location?: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly eventDate?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly time?: string

    /**
     * 
     * @type {number}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly partySize?: number

    /**
     * General search key name for \&quot;event name\&quot; and \&quot;event location\&quot;
     * @type {string}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly keyword?: string

    /**
     * Sort result with key,strategy pattern
     * @type {Array<string>}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly sort?: Array<string>

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof StoreApiStoreControllerFetchEvents
     */
    readonly offset?: number
}

/**
 * Request parameters for storeControllerFetchMenu operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFetchMenuRequest
 */
export interface StoreApiStoreControllerFetchMenuRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFetchMenu
     */
    readonly id: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof StoreApiStoreControllerFetchMenu
     */
    readonly orderDate?: string

    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof StoreApiStoreControllerFetchMenu
     */
    readonly orderTime?: string
}

/**
 * Request parameters for storeControllerFind operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindRequest
 */
export interface StoreApiStoreControllerFindRequest {
    /**
     * 
     * @type {SearchStoreDTO}
     * @memberof StoreApiStoreControllerFind
     */
    readonly searchStoreDTO: SearchStoreDTO
}

/**
 * Request parameters for storeControllerFindOne operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindOneRequest
 */
export interface StoreApiStoreControllerFindOneRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFindOne
     */
    readonly id: string
}

/**
 * Request parameters for storeControllerGetStoreDateOptions operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerGetStoreDateOptionsRequest
 */
export interface StoreApiStoreControllerGetStoreDateOptionsRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerGetStoreDateOptions
     */
    readonly id: string
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Get store events
     * @param {StoreApiStoreControllerFetchEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFetchEvents(requestParameters: StoreApiStoreControllerFetchEventsRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFetchEvents(requestParameters.id, requestParameters.store, requestParameters.price, requestParameters.location, requestParameters.eventDate, requestParameters.time, requestParameters.partySize, requestParameters.keyword, requestParameters.sort, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store menu
     * @param {StoreApiStoreControllerFetchMenuRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFetchMenu(requestParameters: StoreApiStoreControllerFetchMenuRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFetchMenu(requestParameters.id, requestParameters.orderDate, requestParameters.orderTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find store
     * @param {StoreApiStoreControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFind(requestParameters: StoreApiStoreControllerFindRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFind(requestParameters.searchStoreDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store information
     * @param {StoreApiStoreControllerFindOneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFindOne(requestParameters: StoreApiStoreControllerFindOneRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFindOne(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store date options
     * @param {StoreApiStoreControllerGetStoreDateOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerGetStoreDateOptions(requestParameters: StoreApiStoreControllerGetStoreDateOptionsRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerGetStoreDateOptions(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


