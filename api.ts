/* tslint:disable */
/* eslint-disable */
/**
 * Pickup API
 * # Authorization   Pickup API accepts one type of authentication   <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CartDTO
 */
export interface CartDTO {
    /**
     * 
     * @type {Array<CartItemDTO>}
     * @memberof CartDTO
     */
    'items': Array<CartItemDTO>;
    /**
     * 
     * @type {CartDTOCustomer}
     * @memberof CartDTO
     */
    'customer'?: CartDTOCustomer;
    /**
     * PickupPH supported order types
     * @type {string}
     * @memberof CartDTO
     */
    'order_type': CartDTOOrderTypeEnum;
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof CartDTO
     */
    'order_date'?: string;
    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof CartDTO
     */
    'order_time'?: string;
}

export const CartDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup',
    ThirdPartyPickup: 'third_party_pickup',
    CurbsidePickup: 'curbside_pickup'
} as const;

export type CartDTOOrderTypeEnum = typeof CartDTOOrderTypeEnum[keyof typeof CartDTOOrderTypeEnum];

/**
 * Optional customer details, guest users can input their details on the checkout page
 * @export
 * @interface CartDTOCustomer
 */
export interface CartDTOCustomer {
    /**
     * 
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'last_name'?: string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'mobile_number'?: string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CartDTOCustomer
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface CartEntity
 */
export interface CartEntity {
    /**
     * 
     * @type {string}
     * @memberof CartEntity
     */
    'checkout_url': string;
}
/**
 * 
 * @export
 * @interface CartItemDTO
 */
export interface CartItemDTO {
    /**
     * The 24 character hexadecimal string id of the item to be added or modified
     * @type {string}
     * @memberof CartItemDTO
     */
    'id': string;
    /**
     * The item quantity to be set, 0 means item is for removal
     * @type {number}
     * @memberof CartItemDTO
     */
    'quantity': number;
    /**
     * The extra option per item
     * @type {Array<string>}
     * @memberof CartItemDTO
     */
    'extras'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CategoryClass
 */
export interface CategoryClass {
    /**
     * Indicates an item to be an exclusive offering in a meal plan type order
     * @type {boolean}
     * @memberof CategoryClass
     */
    'is_exclusive': boolean;
    /**
     * Category identifier
     * @type {string}
     * @memberof CategoryClass
     */
    'category_name': string;
    /**
     * Position of the category in the menu
     * @type {number}
     * @memberof CategoryClass
     */
    'category_position': number;
    /**
     * The limit of category per day , 0 = category is not limited
     * @type {number}
     * @memberof CategoryClass
     */
    'category_limit_per_day': number;
    /**
     * Limit of category per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof CategoryClass
     */
    'category_limit_per_time_slot': Array<ItemTimeSlotClass>;
    /**
     * True if the category should be visible to the customer
     * @type {boolean}
     * @memberof CategoryClass
     */
    'visible': boolean;
}
/**
 * 
 * @export
 * @interface CustomerDetailDTO
 */
export interface CustomerDetailDTO {
    /**
     * 
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'last_name'?: string;
    /**
     * The customer mobile number, does NOT support e164 format
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'mobile_number'?: string;
    /**
     * A valid customer personal or work email
     * @type {string}
     * @memberof CustomerDetailDTO
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface ExtraGroupClass
 */
export interface ExtraGroupClass {
    /**
     * Indicates if extras within a group is REQUIRED to be added on cart with the item
     * @type {boolean}
     * @memberof ExtraGroupClass
     */
    'is_required': boolean;
    /**
     * The name of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'name': string;
    /**
     * The description of the extra group
     * @type {string}
     * @memberof ExtraGroupClass
     */
    'description': string;
    /**
     * Minimum number of extras within a group that NEEDS to be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'minimum_number': number;
    /**
     * Maximum number of extras within a group that can be added on cart with the item
     * @type {number}
     * @memberof ExtraGroupClass
     */
    'maximum_number': number;
    /**
     * List of extras within a group
     * @type {Array<GroupSelectionClass>}
     * @memberof ExtraGroupClass
     */
    'extras'?: Array<GroupSelectionClass>;
}
/**
 * 
 * @export
 * @interface GroupSelectionClass
 */
export interface GroupSelectionClass {
    /**
     * The unique bson identifier of the extra, to be used on the create cart endpoint
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'id'?: string;
    /**
     * Nominated position of the extra in a list
     * @type {number}
     * @memberof GroupSelectionClass
     */
    'position': number;
    /**
     * Random unique identifier for extras
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'extra_code': string;
    /**
     * Pertains to the regular price of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'price': string;
    /**
     * The name of the extra
     * @type {string}
     * @memberof GroupSelectionClass
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ItemClass
 */
export interface ItemClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemClass
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof ItemClass
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof ItemClass
     */
    'item_code': string;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_meal_plan'?: boolean;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof ItemClass
     */
    'item_limit_per_day'?: number;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof ItemClass
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemClass
     */
    'tags': Array<string>;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemClass
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemInventoryEntity
 */
export interface ItemInventoryEntity {
    /**
     * Number of available item quantity
     * @type {number}
     * @memberof ItemInventoryEntity
     */
    'available': number;
}
/**
 * 
 * @export
 * @interface ItemPartialClass
 */
export interface ItemPartialClass {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof ItemPartialClass
     */
    'id'?: string;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof ItemPartialClass
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof ItemPartialClass
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof ItemPartialClass
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof ItemPartialClass
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof ItemPartialClass
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof ItemPartialClass
     */
    'tags': Array<string>;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof ItemPartialClass
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof ItemPartialClass
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemTimeSlotClass
 */
export interface ItemTimeSlotClass {
    /**
     * Time-slot indicator
     * @type {string}
     * @memberof ItemTimeSlotClass
     */
    'time_slot': string;
    /**
     * Indicates the limit of purchases an item could have in a time slot
     * @type {number}
     * @memberof ItemTimeSlotClass
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface ItemsEntity
 */
export interface ItemsEntity {
    /**
     * 
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemsEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemsEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<ItemPartialClass>}
     * @memberof ItemsEntity
     */
    'result': Array<ItemPartialClass>;
    /**
     * 
     * @type {number}
     * @memberof ItemsEntity
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface MenuClass
 */
export interface MenuClass {
    /**
     * 
     * @type {MenuClassItem}
     * @memberof MenuClass
     */
    'item': MenuClassItem;
    /**
     * Item limit per day 0 = category is not limited
     * @type {number}
     * @memberof MenuClass
     */
    'item_limit_per_day': number;
    /**
     * To check if the item is available
     * @type {boolean}
     * @memberof MenuClass
     */
    'available': boolean;
    /**
     * True if the item should be visible to the customer , item can be available but not be visible
     * @type {boolean}
     * @memberof MenuClass
     */
    'visible': boolean;
    /**
     * Position of the item in the store menu
     * @type {number}
     * @memberof MenuClass
     */
    'order_position': number;
    /**
     * Item category name
     * @type {string}
     * @memberof MenuClass
     */
    'category': string;
    /**
     * Item limit per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClass
     */
    'item_limit_per_time_slot': Array<ItemTimeSlotClass>;
}
/**
 * Item id that will be used for cart building on /cart route
 * @export
 * @interface MenuClassItem
 */
export interface MenuClassItem {
    /**
     * Item id that will be used for cart building on /cart route
     * @type {string}
     * @memberof MenuClassItem
     */
    'id': string;
    /**
     * List of grouped extras of an item
     * @type {Array<ExtraGroupClass>}
     * @memberof MenuClassItem
     */
    'extra_group'?: Array<ExtraGroupClass>;
    /**
     * Random unique item code
     * @type {string}
     * @memberof MenuClassItem
     */
    'item_code': string;
    /**
     * Indicates the item is bulky and will automatically select car on checkout if order type is delivery
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_bulk'?: boolean;
    /**
     * Indicates if item is part of meal plan order type
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_meal_plan'?: boolean;
    /**
     * Store off dates helper
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'off_dates'?: Array<string>;
    /**
     * Maximum number of allowed purchase of the item across all platform per day
     * @type {number}
     * @memberof MenuClassItem
     */
    'item_limit_per_day'?: number;
    /**
     * Maximum number of allowed purchase of the item across all platform per time slot
     * @type {Array<ItemTimeSlotClass>}
     * @memberof MenuClassItem
     */
    'item_limit_per_time_slot'?: Array<ItemTimeSlotClass>;
    /**
     * Store which this item belongs to, can be used for filtering
     * @type {string}
     * @memberof MenuClassItem
     */
    'store_id'?: string;
    /**
     * Store name which this item belongs to
     * @type {string}
     * @memberof MenuClassItem
     */
    'store_name'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'name': string;
    /**
     * The description of the item
     * @type {string}
     * @memberof MenuClassItem
     */
    'description': string;
    /**
     * The nominated item display image in url form
     * @type {string}
     * @memberof MenuClassItem
     */
    'image_url': string;
    /**
     * The item discount description
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_description'?: string;
    /**
     * The peso value of the current active item discount. If discount_type is rawDiscount, this is equal to the discount_value. If percentDiscount, this is equal to the regular_price multiplied to the discount_value/100.
     * @type {string}
     * @memberof MenuClassItem
     */
    'active_discount'?: string;
    /**
     * The active price of the item, if there is an active discount, this should be equal to the discounted_price, if there is no active discount, this should be equal to the regular price
     * @type {string}
     * @memberof MenuClassItem
     */
    'price': string;
    /**
     * The type of discount applied (\"noDiscount\", \"rawDiscount\", \"percentDiscount\")
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_type'?: string;
    /**
     * The value of the discount applied. For example if discount_value is \"20\", if discount_type is percentDiscount, this means 20% off. If discount_type is rawDiscount, this means P20.00 off.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discount_value'?: string;
    /**
     * The peso value of the item, applying the active_discount to the regular_price.
     * @type {string}
     * @memberof MenuClassItem
     */
    'discounted_price': string;
    /**
     * The peso value of the item without any discounts.
     * @type {string}
     * @memberof MenuClassItem
     */
    'regular_price'?: string;
    /**
     * Item tags
     * @type {Array<string>}
     * @memberof MenuClassItem
     */
    'tags': Array<string>;
    /**
     * Indicates item to not be shown to customers on an off-date
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'is_visible_on_off_date'?: boolean;
    /**
     * Item is available for order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'available'?: boolean;
    /**
     * Item category, should be in store category list
     * @type {string}
     * @memberof MenuClassItem
     */
    'category'?: string;
    /**
     * Indicates if item has an extra group to be shown as part of the order
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'extras'?: boolean;
    /**
     * Indicates if item should be visible to the customer
     * @type {boolean}
     * @memberof MenuClassItem
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface StoreClass
 */
export interface StoreClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StoreClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StoreClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StoreClass
     */
    'delivery_distance_limit': number;
    /**
     * Store accepts curbside delivery
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_curbside_active': boolean;
    /**
     * Store accepts pickup order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_pickup_active': boolean;
    /**
     * Store accepts delivery order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_delivery_active': boolean;
    /**
     * Store accepts mealplan order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_meal_plan_active': boolean;
    /**
     * Store accepts dine in order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_dine_in_active': boolean;
    /**
     * Total allowed number of items purchased on a store per day
     * @type {number}
     * @memberof StoreClass
     */
    'store_item_limit_per_day': number;
    /**
     * Indicates if a store accepts and process orders any time of the day
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_open_24_hours': boolean;
    /**
     * List of dates that indicates the store as closed and will NOT accept orders
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'off_dates': Array<string>;
    /**
     * Store order prep time in minutes
     * @type {number}
     * @memberof StoreClass
     */
    'pre_order_to_order_queue_timer': number;
    /**
     * Pre-order limit in days
     * @type {number}
     * @memberof StoreClass
     */
    'days_accepting_in_advanced_orders': number;
    /**
     * Store menu grouped and ordered by category
     * @type {Array<MenuClass>}
     * @memberof StoreClass
     */
    'menu': Array<MenuClass>;
    /**
     * Store category list
     * @type {Array<CategoryClass>}
     * @memberof StoreClass
     */
    'categories': Array<CategoryClass>;
    /**
     * Helper for expected meal plan deliveries dates
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'meal_plan_dates': Array<string>;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StoreClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StoreClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StoreClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StoreClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StoreClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StoreClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StoreClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StoreClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StoreClass
     */
    'is_store_open': boolean;
}
/**
 * 
 * @export
 * @interface StoreHoursClass
 */
export interface StoreHoursClass {
    /**
     * Indicates if the store is open on the specific day
     * @type {boolean}
     * @memberof StoreHoursClass
     */
    'is_open': boolean;
    /**
     * Day of the week 0 = Sunday, 1 = Monday , 2 = Tuesday...
     * @type {string}
     * @memberof StoreHoursClass
     */
    'day': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'opening': string;
    /**
     * 
     * @type {string}
     * @memberof StoreHoursClass
     */
    'closing': string;
}
/**
 * 
 * @export
 * @interface StorePartialClass
 */
export interface StorePartialClass {
    /**
     * Id that will be used on searching store
     * @type {string}
     * @memberof StorePartialClass
     */
    'id': string;
    /**
     * Store background image
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_bg': string;
    /**
     * Store distance limit for deliveries (in kilometers)
     * @type {number}
     * @memberof StorePartialClass
     */
    'delivery_distance_limit': number;
    /**
     * Store opening and closing time
     * @type {Array<StoreHoursClass>}
     * @memberof StorePartialClass
     */
    'store_hours': Array<StoreHoursClass>;
    /**
     * Store display name
     * @type {string}
     * @memberof StorePartialClass
     */
    'name': string;
    /**
     * Store display logo
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_logo': string;
    /**
     * Store description
     * @type {string}
     * @memberof StorePartialClass
     */
    'store_description': string;
    /**
     * Store address string used in delivery order type
     * @type {string}
     * @memberof StorePartialClass
     */
    'location'?: string;
    /**
     * Store JSON geocoded address
     * @type {string}
     * @memberof StorePartialClass
     */
    'geocode_location'?: string;
    /**
     * Store tags
     * @type {Array<string>}
     * @memberof StorePartialClass
     */
    'store_tags'?: Array<string>;
    /**
     * Merchant displayed contact number
     * @type {string}
     * @memberof StorePartialClass
     */
    'contact_number': string;
    /**
     * Store status helper, pertains to store being open and will be accepting order
     * @type {boolean}
     * @memberof StorePartialClass
     */
    'is_store_open': boolean;
}
/**
 * 
 * @export
 * @interface StoresEntity
 */
export interface StoresEntity {
    /**
     * 
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_next_page': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoresEntity
     */
    'has_prev_page': boolean;
    /**
     * 
     * @type {number}
     * @memberof StoresEntity
     */
    'total_pages': number;
    /**
     * 
     * @type {Array<StorePartialClass>}
     * @memberof StoresEntity
     */
    'result': Array<StorePartialClass>;
    /**
     * 
     * @type {number}
     * @memberof StoresEntity
     */
    'page': number;
}

/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate: async (cartDTO: CartDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDTO' is not null or undefined
            assertParamExists('cartControllerCreate', 'cartDTO', cartDTO)
            const localVarPath = `/v1/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerCreate(cartDTO: CartDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerCreate(cartDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Create cart
         * @param {CartDTO} cartDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerCreate(cartDTO: CartDTO, options?: any): AxiosPromise<CartEntity> {
            return localVarFp.cartControllerCreate(cartDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cartControllerCreate operation in CartApi.
 * @export
 * @interface CartApiCartControllerCreateRequest
 */
export interface CartApiCartControllerCreateRequest {
    /**
     * 
     * @type {CartDTO}
     * @memberof CartApiCartControllerCreate
     */
    readonly cartDTO: CartDTO
}

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Create cart
     * @param {CartApiCartControllerCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerCreate(requestParameters: CartApiCartControllerCreateRequest, options?: AxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerCreate(requestParameters.cartDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get server information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetServerInfo(options?: any): AxiosPromise<object> {
            return localVarFp.appControllerGetServerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get server information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetServerInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerAggregateId', 'id', id)
            const localVarPath = `/v1/item/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch: async (name?: string, storeId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/item`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['store_id'] = storeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity: async (id: string, orderDate?: string, orderTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerGetSoldQuantity', 'id', id)
            const localVarPath = `/v1/item/{id}/stock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerAggregateSearch(name, storeId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemInventoryEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerGetSoldQuantity(id, orderDate, orderTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get item data
         * @param {string} id ID of item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateId(id: string, options?: any): AxiosPromise<ItemClass> {
            return localVarFp.itemControllerAggregateId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search items by name
         * @param {string} [name] Item name search key, part of full name
         * @param {string} [storeId] Filter items via store ID
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerAggregateSearch(name?: string, storeId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ItemsEntity> {
            return localVarFp.itemControllerAggregateSearch(name, storeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get inventory of an item
         * @param {string} id ID of item
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerGetSoldQuantity(id: string, orderDate?: string, orderTime?: string, options?: any): AxiosPromise<ItemInventoryEntity> {
            return localVarFp.itemControllerGetSoldQuantity(id, orderDate, orderTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for itemControllerAggregateId operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateIdRequest
 */
export interface ItemApiItemControllerAggregateIdRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerAggregateId
     */
    readonly id: string
}

/**
 * Request parameters for itemControllerAggregateSearch operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerAggregateSearchRequest
 */
export interface ItemApiItemControllerAggregateSearchRequest {
    /**
     * Item name search key, part of full name
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly name?: string

    /**
     * Filter items via store ID
     * @type {string}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly storeId?: string

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof ItemApiItemControllerAggregateSearch
     */
    readonly offset?: number
}

/**
 * Request parameters for itemControllerGetSoldQuantity operation in ItemApi.
 * @export
 * @interface ItemApiItemControllerGetSoldQuantityRequest
 */
export interface ItemApiItemControllerGetSoldQuantityRequest {
    /**
     * ID of item
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly id: string

    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderDate?: string

    /**
     * Order time in HH:MM format, void (omitting it) means order is ASAP (current system, or nearest available time slot)
     * @type {string}
     * @memberof ItemApiItemControllerGetSoldQuantity
     */
    readonly orderTime?: string
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Get item data
     * @param {ItemApiItemControllerAggregateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateId(requestParameters: ItemApiItemControllerAggregateIdRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search items by name
     * @param {ItemApiItemControllerAggregateSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerAggregateSearch(requestParameters: ItemApiItemControllerAggregateSearchRequest = {}, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerAggregateSearch(requestParameters.name, requestParameters.storeId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get inventory of an item
     * @param {ItemApiItemControllerGetSoldQuantityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerGetSoldQuantity(requestParameters: ItemApiItemControllerGetSoldQuantityRequest, options?: AxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerGetSoldQuantity(requestParameters.id, requestParameters.orderDate, requestParameters.orderTime, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
         * @param {string} [name] Part or full name of the store
         * @param {Array<string>} [tags] Store tags filter comma separated
         * @param {number} [maxDistance] Maximum store distance from the customer in kilometers
         * @param {boolean} [openOnly] Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in'} [orderType] Store supported fulfillment service
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind: async (orderDate?: string, orderTime?: string, name?: string, tags?: Array<string>, maxDistance?: number, openOnly?: boolean, orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in', limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (orderDate !== undefined) {
                localVarQueryParameter['order_date'] = orderDate;
            }

            if (orderTime !== undefined) {
                localVarQueryParameter['order_time'] = orderTime;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (maxDistance !== undefined) {
                localVarQueryParameter['max_distance'] = maxDistance;
            }

            if (openOnly !== undefined) {
                localVarQueryParameter['open_only'] = openOnly;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeControllerFindOne', 'id', id)
            const localVarPath = `/v1/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
         * @param {string} [name] Part or full name of the store
         * @param {Array<string>} [tags] Store tags filter comma separated
         * @param {number} [maxDistance] Maximum store distance from the customer in kilometers
         * @param {boolean} [openOnly] Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in'} [orderType] Store supported fulfillment service
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFind(orderDate?: string, orderTime?: string, name?: string, tags?: Array<string>, maxDistance?: number, openOnly?: boolean, orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in', limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFind(orderDate, orderTime, name, tags, maxDistance, openOnly, orderType, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Find store
         * @param {string} [orderDate] ISO8601 compliant date string, defaults to current server date
         * @param {string} [orderTime] Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
         * @param {string} [name] Part or full name of the store
         * @param {Array<string>} [tags] Store tags filter comma separated
         * @param {number} [maxDistance] Maximum store distance from the customer in kilometers
         * @param {boolean} [openOnly] Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
         * @param {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in'} [orderType] Store supported fulfillment service
         * @param {number} [limit] The number of record to return, 0 means all will be returned
         * @param {number} [offset] The number of records to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFind(orderDate?: string, orderTime?: string, name?: string, tags?: Array<string>, maxDistance?: number, openOnly?: boolean, orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in', limit?: number, offset?: number, options?: any): AxiosPromise<StoresEntity> {
            return localVarFp.storeControllerFind(orderDate, orderTime, name, tags, maxDistance, openOnly, orderType, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get store information
         * @param {string} id ID of store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFindOne(id: string, options?: any): AxiosPromise<StoreClass> {
            return localVarFp.storeControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeControllerFind operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindRequest
 */
export interface StoreApiStoreControllerFindRequest {
    /**
     * ISO8601 compliant date string, defaults to current server date
     * @type {string}
     * @memberof StoreApiStoreControllerFind
     */
    readonly orderDate?: string

    /**
     * Pre-order time filter in HH:MM format, void (omitting it) means stores that accepts ASAP order will be returned
     * @type {string}
     * @memberof StoreApiStoreControllerFind
     */
    readonly orderTime?: string

    /**
     * Part or full name of the store
     * @type {string}
     * @memberof StoreApiStoreControllerFind
     */
    readonly name?: string

    /**
     * Store tags filter comma separated
     * @type {Array<string>}
     * @memberof StoreApiStoreControllerFind
     */
    readonly tags?: Array<string>

    /**
     * Maximum store distance from the customer in kilometers
     * @type {number}
     * @memberof StoreApiStoreControllerFind
     */
    readonly maxDistance?: number

    /**
     * Store status filter, null means all stores will be returned regardless if it is open or closed on the selected order_date and order_time
     * @type {boolean}
     * @memberof StoreApiStoreControllerFind
     */
    readonly openOnly?: boolean

    /**
     * Store supported fulfillment service
     * @type {'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in'}
     * @memberof StoreApiStoreControllerFind
     */
    readonly orderType?: 'delivery' | 'pickup' | 'third_party_pickup' | 'curbside_pickup' | 'dine_in'

    /**
     * The number of record to return, 0 means all will be returned
     * @type {number}
     * @memberof StoreApiStoreControllerFind
     */
    readonly limit?: number

    /**
     * The number of records to skip
     * @type {number}
     * @memberof StoreApiStoreControllerFind
     */
    readonly offset?: number
}

/**
 * Request parameters for storeControllerFindOne operation in StoreApi.
 * @export
 * @interface StoreApiStoreControllerFindOneRequest
 */
export interface StoreApiStoreControllerFindOneRequest {
    /**
     * ID of store
     * @type {string}
     * @memberof StoreApiStoreControllerFindOne
     */
    readonly id: string
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Find store
     * @param {StoreApiStoreControllerFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFind(requestParameters: StoreApiStoreControllerFindRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFind(requestParameters.orderDate, requestParameters.orderTime, requestParameters.name, requestParameters.tags, requestParameters.maxDistance, requestParameters.openOnly, requestParameters.orderType, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get store information
     * @param {StoreApiStoreControllerFindOneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFindOne(requestParameters: StoreApiStoreControllerFindOneRequest, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFindOne(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


